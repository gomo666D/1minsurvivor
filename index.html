<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Zombie Rollerz: Bigger Boomerang Hitbox</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        html, body { margin: 0; padding: 0; background: #000; width: 100%; height: 100%; overflow: hidden; font-family: 'Press Start 2P', monospace; letter-spacing: 0.5px; text-transform: uppercase; }
        canvas { display: block; margin: 0 auto; background: #000; }
        body { display: flex; justify-content: center; align-items: center; touch-action: none; color: #fff; }
        
        #game-wrapper { 
            position: relative; width: 100%; height: 100%; 
            max-width: 540px; aspect-ratio: 9/16; 
            background: #000; overflow: hidden; 
            box-shadow: 0 0 30px rgba(0,0,0,0.5); 
            border: 2px solid #666; 
        }
        canvas { display: block; width: 100%; height: 100%; }
        #rotate-msg { display: none; }

        /* 添加这行代码将隐藏 Debug 和 SFX 按钮 */
        #debug-btn, #sfxTestBtn, #sfxTestBtn2, #sfxTestPanel, #sfxTestPanel2 {
                display: none !important;
                }

        /* === 结算界面主容器 === */
        #game-over-ui {
            display: none; 
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.94);
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            z-index: 100;
            color: white;
            text-align: center;
            font-family: 'Press Start 2P', monospace !important;
            padding: 20px 5%; 
            padding-bottom: 40px; 
            box-sizing: border-box; 
        }
        
        /* === 上半部分 === */
        #go-top-section {
            width: 100%; 
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            margin-bottom: 10px; 
            flex-shrink: 0;
        }

        #go-title { display: none !important; }
        
        .score-row { 
            display: flex; gap: 12px; font-size: 14px; margin: 5px 0; color: #ddd; 
            flex-wrap: nowrap; white-space: nowrap; 
        }
        .highlight { color: #FFD700; font-weight: bold; font-size: 16px; }
        
        #input-area { margin-top: 8px; margin-bottom: 8px; }
        
        input[type="text"] {
            padding: 10px; font-size: 12px; text-align: center;
            border: 2px solid #FFD700; border-radius: 5px; 
            background: #222; color: white; width: 200px;
            font-family: 'Press Start 2P', monospace;
            transition: all 0.3s;
        }
        #player-name-input.nickname-locked {
            border-color: transparent !important;
            background-color: transparent !important;
            color: #FFFFFF !important;
            opacity: 1; pointer-events: none;
            text-shadow: 0 2px 0 #000;
        }

        button#restart-btn {
            padding: 12px 24px; font-size: 13px; font-weight: bold;
            background: #FF4500; color: white; border: none; border-radius: 5px;
            cursor: pointer; transition: transform 0.1s; min-width: 180px; 
            font-family: 'Press Start 2P', monospace;
            box-shadow: 0 4px 0 #b33200;
        }
        button#restart-btn:active { transform: scale(0.95); box-shadow: 0 2px 0 #b33200; transform: translateY(2px); }

        /* 分割线 */
        .section-divider {
            width: 90%; height: 2px; background-color: #444;
            margin: 20px 0 15px 0; flex-shrink: 0;
        }

        /* === 下半部分 === */
        #leaderboard-section {
            width: 100%; flex: 1; 
            display: flex; flex-direction: column; 
            align-items: center; overflow: hidden; min-height: 0;
        }

        .lb-main-title {
            color: #FFD700; font-size: 16px; margin: 0 0 10px 0; text-shadow: 0 2px 0 #000;
        }

        .lb-sub-label {
            width: 95%; max-width: 420px;
            text-align: left; font-size: 10px; color: #888;
            margin-top: 5px; margin-bottom: 5px; letter-spacing: 1px;
        }

        #lb-status { color:#bbb; font-size:10px; margin: 2px 0; min-height: 12px; }

        /* 列表 */
        #lb-top10 { 
            width: 95%; max-width: 420px; 
            flex: 1; overflow-y: auto; 
            display:flex; flex-direction:column; gap: 6px; padding-right: 2px;
        }

        /* 行样式 */
        .lb-item {
            display:flex; justify-content:space-between; align-items:center;
            padding: 12px 14px; border-radius: 6px;
            border: 1px solid rgba(255,255,255,0.1);
            background: rgba(0,0,0,0.4);
            font-size: 12px; line-height: 1.5; flex-shrink: 0;
        }
        .lb-left { display:flex; gap:10px; align-items:center; overflow:hidden; }
        .lb-rank { min-width: 32px; color:#FFD700; font-weight: 900; }
        .lb-name { 
            color:#fff; font-weight: 800; 
            white-space:nowrap; overflow:hidden; text-overflow:ellipsis; 
            max-width: 150px; 
        }
        .lb-score { color:#FFD700; font-weight: 900; margin-left: auto; }

        /* 我的排名 */
        #lb-my-rank-container {
            width: 95%; max-width: 420px; flex-shrink: 0;
            margin-bottom: 12px; min-height: 40px;
        }
        .my-rank-row {
            background: rgba(184, 134, 11, 0.7) !important;
            border: 1px solid #FFD700 !important; 
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.2);
        }

        #happy-sprite-text {
            display: flex; justify-content: center; align-items: center;
            flex-wrap: nowrap; gap: 0px; margin-bottom: 10px;
            width: 100%; transform: scale(1.0); 
        }
        .hny-letter { background-repeat: no-repeat; image-rendering: pixelated; flex: 0 0 auto; }
        .hny-space { flex: 0 0 auto; height: 1px; }

        #go-title, #name-display-area, #lb-myline { display: none !important; }
        
        #debug-btn {
            position: absolute; bottom: 5px; left: 5px; z-index: 500;
            padding: 6px 10px; background: rgba(0, 0, 0, 0.6);
            color: #00FF00; border: 1px solid #00FF00;
            font-family: monospace; font-size: 12px; pointer-events: auto;
        }

        @media screen and (orientation: landscape) and (max-width: 900px) {
            #game-wrapper { display: none; }
            #rotate-msg { display: block; text-align: center; font-size: 20px; margin-top: 20%; color: #fff; }
        }
    </style>
    
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js">
// SFX debug toggle
window.SFX_DEBUG = true;
</script>
    <script>
    (function(){
      window.addEventListener('DOMContentLoaded', () => {
          const input = document.getElementById('player-name-input');
          if (!input) return;
          try{
            const saved = localStorage.getItem('playerNickname'); 
            const saved2 = localStorage.getItem('zr_player_name');
            const locked = localStorage.getItem('zr_name_locked') === "1";
            if ((saved && saved.trim().length > 0) || (saved2 && saved2.trim().length > 0)){
              input.value = saved2 || saved;
              if (locked) {
                  input.classList.add('nickname-locked');
                  input.readOnly = true; input.disabled = true;
              }
            }
          }catch(e){}
      });
    })();
    

// ===== BGM (HTMLAudioElement) =====
const BGM = (() => {
  let el = null;
  let started = false;

  function ensure() {
    if (!el) el = document.getElementById('bgm');
    return el;
  }

  async function start() {
    const a = ensure();
    if (!a) return;
    a.volume = 0.5;
    try {
      // Always restart from beginning when entering gameplay
      a.currentTime = 0;
    } catch (e) {}
    try {
      const p = a.play();
      if (p && typeof p.then === 'function') await p;
      started = true;
    } catch (e) {
      // Autoplay blocked: will retry on next user gesture
      started = false;
      console.log('[BGM] play blocked:', e && e.message ? e.message : e);
    }
  }

  function stop() {
    const a = ensure();
    if (!a) return;
    try { a.pause(); } catch (e) {}
    try { a.currentTime = 0; } catch (e) {}
    started = false;
  }

  function isStarted() { return started; }

  // Pause on tab hidden (avoid stuck audio)
  document.addEventListener('visibilitychange', () => {
    const a = ensure();
    if (!a) return;
    if (document.hidden) {
      try { a.pause(); } catch (e) {}
    }
  });

  return { start, stop, isStarted };
})();

</script>
</head>
<body>

<div id="rotate-msg">请旋转手机使用竖屏游玩<br>Please Rotate to Portrait</div>

<div id="game-wrapper">
    <div id="game-container"></div>
    <button id="debug-btn">DEBUG: OFF</button>

    <div id="game-over-ui">
        <!-- 上部 -->
        <div id="go-top-section">
            <h1 id="go-title"></h1>
            <div id="happy-sprite-text"></div>
            <div id="name-display-area" style="display:none;"></div>
            
            <div class="score-row">
                <div>Score: <span id="go-score" class="highlight">0</span></div>
                <div>Best: <span id="go-best" class="highlight">0</span></div>
            </div>
            <div style="font-size: 16px; color: #FF0000; margin-bottom: 5px;" id="go-letters"></div>
            <div id="input-area">
                <input type="text" id="player-name-input" placeholder="Enter Name" maxlength="12">
            </div>
            <div id="go-button-row">
                <button id="restart-btn">PLAY AGAIN</button>
            </div>
        </div>
        
        <div class="section-divider"></div>
        
        <div id="leaderboard-section">
            <h2 class="lb-main-title">GLOBAL RANKING</h2>
            <div id="lb-status">Checking...</div>
            
            <div class="lb-sub-label">YOUR POSITION</div>
            <div id="lb-my-rank-container"></div>
            
            <div class="lb-sub-label">TOP PLAYERS</div>
            <div id="lb-top10"></div>
        </div>
    </div>
</div>

<script>
const DEBUG_SLOTS = false; 

function renderHappyNewYearSpritesDOM(collectedIndexSet) {
    const container = document.getElementById('happy-sprite-text');
    if (!container) return;
    const total = 12; 
    const scale = 0.26;
    const fw = 110, fh = 128;
    const cols = 4, rows = 3;
    const w = Math.round(fw * scale);
    const h = Math.round(fh * scale);
    const sheetW = Math.round((fw * cols) * scale);
    const sheetH = Math.round((fh * rows) * scale);

    container.innerHTML = '';
    for (let i = 0; i < total; i++) {
        if (i === 5 || i === 8) {
            const sp = document.createElement('div');
            sp.className = 'hny-space';
            sp.style.width = Math.round(18 * scale) + 'px';
            container.appendChild(sp);
        }
        const col = i % 4;
        const row = Math.floor(i / 4);
        const el = document.createElement('div');
        el.className = 'hny-letter';
        el.style.width = w + 'px';
        el.style.height = h + 'px';
        const collected = collectedIndexSet && collectedIndexSet.has && collectedIndexSet.has(i);
        if (collected) {
            el.style.backgroundImage = "url('assets/text_happynewyear.png')";
            el.style.backgroundSize = `${sheetW}px ${sheetH}px`;
            el.style.backgroundPosition = `${-col * w}px ${-row * h}px`;
        } else {
            el.style.backgroundImage = "url('assets/text_question.png')";
            el.style.backgroundSize = 'contain';
            el.style.backgroundPosition = 'center';
        }
        container.appendChild(el);
    }
}

const CONFIG = {
    PLAYER_SCALE: 0.85, 
    SPEED_PLAYER: 150,    
    SPEED_ZOMBIE_BASE: 100, 
    HP_ZOMBIE_BASE: 10,     
    BULLET_SPEED: 1500,   
    FIRE_RATE: 25,       
    HP_TRAMPLE_COST: 5,
    COMBO_TIMEOUT: 1000,
    MAGNET_DIST: 400, 
    MAGNET_SPEED: 600, 
    LIMIT_POWERUP: 8,
    LIMIT_HEART: 10,
    BOOMERANG_RADIUS: 140, 
    BOOMERANG_SPEED: 0.15, 
    DAMAGE_BOOMERANG: 5,
    DAMAGE_CANNON: 5,
    CANNON_AOE_RADIUS: 120, 
    CANNON_KNOCKBACK: 600,
    CANNON_STUN_DURATION: 500,
    HIT_STUN_DURATION: 100 
};

// ===== 8-bit Procedural SFX (WebAudio) =====
const SFX = (() => {
  const SFX_DEBUG = true;
  function sfxDbg(tag, data){
    if(!SFX_DEBUG) return;
    try{
      const st = (ctx && ctx.state) ? ctx.state : 'no_ctx';
      console.log(`[SFX] ${tag}`, {state: st, ...(data||{})});
    }catch(e){}
  }
  let ctx = null;
  let master = null;

  function ensure() {
    if (!ctx) {
      ctx = new (window.AudioContext || window.webkitAudioContext)();
      sfxDbg('AudioContext created', {sampleRate: ctx.sampleRate});
      sfxDbg('AudioContext created', {sampleRate: ctx.sampleRate});
      master = ctx.createGain();
      master.gain.value = 0.35;
      sfxDbg('Master gain', {gain: master.gain.value}); // overall SFX volume
      master.connect(ctx.destination);
    }
    if (ctx.state === 'suspended') { sfxDbg('AudioContext resume()', {before: ctx.state}); ctx.resume().then(()=>sfxDbg('AudioContext resumed', {after: ctx.state})).catch(e=>sfxDbg('AudioContext resume failed', {err: e && e.message ? e.message : String(e)})); }
  }

  function now() { try{ ensure(); }catch(e){ sfxDbg('ensure() failed', {err: e && e.message ? e.message : String(e)}); throw e; } return ctx.currentTime; }

  function env(gainNode, t, a, d, s, r, peak=0.9) {
    const g = gainNode.gain;
    g.cancelScheduledValues(t);
    g.setValueAtTime(0.0001, t);
    g.linearRampToValueAtTime(peak, t + a);
    g.linearRampToValueAtTime(peak * s, t + a + d);
    g.linearRampToValueAtTime(0.0001, t + a + d + r);
  }

  function osc(type, freq, t, dur, gain=0.6, detune=0) {
    ensure();
    const o = ctx.createOscillator();
    const g = ctx.createGain();
    o.type = type;
    o.frequency.setValueAtTime(freq, t);
    o.detune.setValueAtTime(detune, t);
    g.gain.setValueAtTime(gain, t);
    o.connect(g);
    g.connect(master);
    o.start(t);
    o.stop(t + dur);
    return { o, g };
  }

  function noise(t, dur, gain=0.25) {
    ensure();
    const bufferSize = Math.floor(ctx.sampleRate * dur);
    const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1);
    const src = ctx.createBufferSource();
    src.buffer = buffer;
    const g = ctx.createGain();
    g.gain.setValueAtTime(gain, t);
    src.connect(g);
    g.connect(master);
    src.start(t);
    src.stop(t + dur);
    return { src, g };
  }

  function pitchSlide(o, t, fromHz, toHz, dur) {
    o.frequency.setValueAtTime(fromHz, t);
    o.frequency.exponentialRampToValueAtTime(Math.max(1, toHz), t + dur);
  }

  function click(t, gain=0.2) {
    const n = noise(t, 0.02, gain);
    env(n.g, t, 0.001, 0.01, 0.3, 0.02, gain);
  }

  return {
    init: () => { sfxDbg('init()'); ensure(); },

    
    ui_start() {
      sfxDbg('ui_start');
      const t = now();
      // race start: 3 beeps + GO sweep
      const beepFreq = 880;
      [0.00, 0.14, 0.28].forEach((dt) => {
        const tt = t + dt;
        const b = osc('square', beepFreq, tt, 0.08, 0.28);
        env(b.g, tt, 0.001, 0.02, 0.10, 0.06, 0.90);
      });

      // short "go" sweep + noise pop
      const go = osc('square', 660, t + 0.42, 0.22, 0.32);
      env(go.g, t + 0.42, 0.001, 0.03, 0.18, 0.10, 0.85);
      pitchSlide(go.o, t + 0.42, 660, 1320, 0.22);

      const pop = noise(t + 0.42, 0.18, 0.12);
      env(pop.g, t + 0.42, 0.001, 0.02, 0.10, 0.10, 0.65);

      // tiny engine rev tail
      const rev = osc('triangle', 120, t + 0.46, 0.26, 0.16);
      env(rev.g, t + 0.46, 0.001, 0.04, 0.14, 0.18, 0.55);
      pitchSlide(rev.o, t + 0.46, 120, 220, 0.26);
    },

    ship_explode() {
      sfxDbg('ship_explode');
      const t = now();
      // heavier, more "ship" explosion than normal explosion
      const n1 = noise(t, 0.95, 0.48);
      env(n1.g, t, 0.001, 0.10, 0.18, 0.85, 1.0);

      const rumble = osc('triangle', 55, t, 1.05, 0.34);
      env(rumble.g, t, 0.001, 0.08, 0.15, 0.95, 0.90);
      pitchSlide(rumble.o, t, 90, 28, 1.05);

      const crack = osc('square', 190, t + 0.02, 0.42, 0.18);
      env(crack.g, t + 0.02, 0.001, 0.04, 0.12, 0.36, 0.70);
      pitchSlide(crack.o, t + 0.02, 260, 70, 0.42);

      const debris = noise(t + 0.05, 0.70, 0.22);
      env(debris.g, t + 0.05, 0.001, 0.08, 0.12, 0.60, 0.35);
    },

    survival_fail() {
      sfxDbg('survival_fail');
      const t = now();
      // ~2s melodic fail jingle (descending), single-shot (no looping)
      const melody = [659.25, 622.25, 587.33, 523.25, 493.88, 440.00, 392.00, 349.23, 329.63];
      const step = 0.14; // 9 * 0.14 = 1.26s sequence
      melody.forEach((f, i) => {
        const tt = t + i * step;
        const a = osc('square', f, tt, 0.20, 0.20);
        env(a.g, tt, 0.001, 0.03, 0.22, 0.16, 0.80);
        // subtle harmony
        const h = osc('triangle', f / 2, tt, 0.20, 0.09);
        env(h.g, tt, 0.001, 0.03, 0.22, 0.16, 0.55);
      });

      // low bass "defeat" sweep that lasts ~2s total
      const bass = osc('triangle', 90, t, 2.0, 0.16);
      env(bass.g, t, 0.001, 0.08, 0.18, 1.90, 0.70);
      pitchSlide(bass.o, t, 90, 35, 2.0);

      // light noise tail for texture
      const n = noise(t + 0.05, 1.2, 0.06);
      env(n.g, t + 0.05, 0.001, 0.08, 0.15, 1.05, 0.20);
    },
ui_click() {
      sfxDbg('ui_click');
      const _t = now();
      sfxDbg('\g<0>', {t:_t});
      const t = _t;
      click(t, 0.55);
    },

    enemy_hit() {
      sfxDbg('enemy_hit');
      const _t = now();
      sfxDbg('\g<0>', {t:_t});
      const t = _t;
      const a = osc('square', 420, t, 0.08, 0.35);
      env(a.g, t, 0.001, 0.02, 0.25, 0.06, 0.5);
      pitchSlide(a.o, t, 520, 260, 0.08);
    },

    enemy_die() {
      sfxDbg('enemy_die');
      const _t = now();
      sfxDbg('\g<0>', {t:_t});
      const t = _t;
      const a = osc('square', 220, t, 0.18, 0.35);
      env(a.g, t, 0.001, 0.03, 0.25, 0.14, 0.7);
      pitchSlide(a.o, t, 260, 80, 0.18);
      const n = noise(t, 0.12, 0.18);
      env(n.g, t, 0.001, 0.02, 0.25, 0.10, 0.25);
    },

    player_hit() {
      sfxDbg('player_hit');
      const _t = now();
      sfxDbg('\g<0>', {t:_t});
      const t = _t;
      const a = osc('square', 140, t, 0.12, 0.45);
      env(a.g, t, 0.001, 0.03, 0.20, 0.10, 0.8);
      pitchSlide(a.o, t, 180, 90, 0.12);
      const n = noise(t, 0.06, 0.12);
      env(n.g, t, 0.001, 0.01, 0.30, 0.05, 0.18);
    },

    explosion() {
      sfxDbg('explosion');
      const t = now();
      // longer + punchier explosion (+50% duration)
      const n1 = noise(t, 0.68, 0.42);
      env(n1.g, t, 0.001, 0.08, 0.20, 0.55, 0.95);

      const n2 = noise(t + 0.02, 0.55, 0.22);
      env(n2.g, t + 0.02, 0.001, 0.06, 0.18, 0.50, 0.35);

      const thump = osc('triangle', 80, t, 0.78, 0.28);
      env(thump.g, t, 0.001, 0.06, 0.18, 0.70, 0.70);
      pitchSlide(thump.o, t, 110, 35, 0.78);

      const crack = osc('square', 160, t + 0.01, 0.30, 0.16);
      env(crack.g, t + 0.01, 0.001, 0.03, 0.15, 0.26, 0.55);
      pitchSlide(crack.o, t + 0.01, 220, 90, 0.30);
    },

    powerup_pickup() {
      sfxDbg('powerup_pickup');
      const _t = now();
      sfxDbg('\g<0>', {t:_t});
      const t = _t;
      const a1 = osc('square', 880, t, 0.20, 0.22);
      env(a1.g, t, 0.001, 0.03, 0.35, 0.16, 0.8);
      const a2 = osc('square', 1320, t + 0.03, 0.18, 0.18);
      env(a2.g, t + 0.03, 0.001, 0.03, 0.35, 0.14, 0.6);
    },

    hp_pickup() {
      sfxDbg('hp_pickup');
      const _t = now();
      sfxDbg('\g<0>', {t:_t});
      const t = _t;
      const a = osc('triangle', 520, t, 0.22, 0.22);
      env(a.g, t, 0.001, 0.03, 0.40, 0.18, 0.7);
      pitchSlide(a.o, t, 480, 720, 0.12);
    },

    letter_collect() {
      sfxDbg('letter_collect');
      const _t = now();
      sfxDbg('\g<0>', {t:_t});
      const t = _t;
      const a = osc('square', 740, t, 0.14, 0.18);
      env(a.g, t, 0.001, 0.02, 0.35, 0.11, 0.7);
      const b = osc('square', 988, t + 0.04, 0.12, 0.14);
      env(b.g, t + 0.04, 0.001, 0.02, 0.35, 0.09, 0.5);
    },

    survive_success() {
      sfxDbg('survive_success');
      const t = now();

      // "Stage Clear" style jingle (~2.0s): fast arpeggio + cadence + held chord
      const lead = [
        523.25, 659.25, 783.99, 1046.50,   // C E G C
        659.25, 783.99, 1046.50, 1318.51,  // E G C E
        783.99, 1046.50, 1318.51, 1567.98, // G C E G
        1046.50, 1318.51, 1567.98, 2093.00 // C E G C (high)
      ];
      const step = 0.075; // 16 * 0.075 = 1.20s
      lead.forEach((f, i) => {
        const tt = t + i * step;
        const a = osc('square', f, tt, 0.12, 0.22);
        env(a.g, tt, 0.001, 0.02, 0.35, 0.06, 0.85);

        // bass on downbeats
        if (i % 4 === 0) {
          const b = osc('triangle', f / 4, tt, 0.12, 0.10);
          env(b.g, tt, 0.001, 0.02, 0.35, 0.08, 0.65);
        }

        // tiny sparkle hit
        if (i % 8 === 4) {
          const sp = noise(tt, 0.05, 0.05);
          env(sp.g, tt, 0.001, 0.01, 0.10, 0.04, 0.35);
        }
      });

      // Cadence (1.2s -> 1.55s): V -> I
      const cadT = t + lead.length * step;
      const cad1 = osc('square', 987.77, cadT, 0.18, 0.18);  // B
      const cad2 = osc('square', 1318.51, cadT, 0.18, 0.14); // E
      env(cad1.g, cadT, 0.001, 0.02, 0.20, 0.16, 0.75);
      env(cad2.g, cadT, 0.001, 0.02, 0.20, 0.16, 0.70);

      // Final held major chord (to ~2s)
      const chordT = cadT + 0.20;
      const c1 = osc('square', 1046.50, chordT, 0.75, 0.20); // C
      const c2 = osc('square', 1318.51, chordT, 0.75, 0.16); // E
      const c3 = osc('square', 1567.98, chordT, 0.75, 0.14); // G
      env(c1.g, chordT, 0.001, 0.03, 0.18, 0.70, 0.90);
      env(c2.g, chordT, 0.001, 0.03, 0.18, 0.70, 0.86);
      env(c3.g, chordT, 0.001, 0.03, 0.18, 0.70, 0.82);

      const tail = noise(chordT + 0.02, 0.45, 0.05);
      env(tail.g, chordT + 0.02, 0.001, 0.03, 0.20, 0.40, 0.40);
    },
    turret_install() {
      sfxDbg('turret_install');
      const t = now();
      // mechanical clamp: click + short square blip
      const a = osc('square', 320, t, 0.12, 0.22);
      env(a.g, t, 0.001, 0.02, 0.25, 0.10, 0.7);
      pitchSlide(a.o, t, 360, 240, 0.10);
      const n = noise(t, 0.03, 0.10);
      env(n.g, t, 0.001, 0.01, 0.20, 0.02, 0.18);
    },

    word_complete() {
      sfxDbg('word_complete');
      const t = now();
      // small win arpeggio
      const notes = [523.25, 659.25, 783.99]; // C5 E5 G5
      notes.forEach((f, i) => {
        const tt = t + i * 0.06;
        const a = osc('square', f, tt, 0.10, 0.16);
        env(a.g, tt, 0.001, 0.02, 0.30, 0.08, 0.65);
      });
    },

    all_letters_complete() {
      sfxDbg('all_letters_complete');
      const t = now();
      // brighter fanfare
      const notes = [523.25, 659.25, 783.99, 1046.5]; // C5 E5 G5 C6
      notes.forEach((f, i) => {
        const tt = t + i * 0.08;
        const a = osc('square', f, tt, 0.14, 0.18);
        env(a.g, tt, 0.001, 0.02, 0.35, 0.12, 0.75);
      });
      const n = noise(t + 0.06, 0.18, 0.10);
      env(n.g, t + 0.06, 0.001, 0.03, 0.25, 0.14, 0.22);
    },

    leaderboard_submit() {
      sfxDbg('leaderboard_submit');
      const t = now();
      // UI confirm ping
      const a = osc('triangle', 880, t, 0.12, 0.16);
      env(a.g, t, 0.001, 0.02, 0.35, 0.10, 0.6);
      const b = osc('triangle', 1174.66, t + 0.03, 0.10, 0.12);
      env(b.g, t + 0.03, 0.001, 0.02, 0.35, 0.08, 0.5);
    },

    leaderboard_rank_up() {
      sfxDbg('leaderboard_rank_up');
      const t = now();
      // celebratory chord-ish blips
      const notes = [659.25, 783.99, 987.77]; // E5 G5 B5
      notes.forEach((f, i) => {
        const tt = t + i * 0.02;
        const a = osc('square', f, tt, 0.18, 0.14);
        env(a.g, tt, 0.001, 0.03, 0.30, 0.16, 0.7);
      });
    },
  };
})()

// Expose SFX for debug/test UI
window.SFX = SFX;
// Backward/alias names for test + future hooks (no gameplay change)
if (!window.SFX.ui_start && window.SFX.ui_click) window.SFX.ui_start = window.SFX.ui_click;
if (!window.SFX.ship_explode && window.SFX.explosion) window.SFX.ship_explode = window.SFX.explosion;

;


const COLORS = {
    PLAYER_BODY: 0x888888, PLAYER_DECK: 0xAAAAAA, 
    WHEEL: 0x222222, WHEEL_TREAD: 0x000000, 
    TURRET: 0xFFD700, HEART:  0xFF1493, LETTER: '#FF0000',     
    BULLET: 0xFF8C00, ARROW:  0x333333,
    POWERUP_BG: 0x800080, POWERUP_TEXT: '#FFFFFF',
    HAPPY: 0xFFD700, BOOMERANG_RING: 0xFFFF00,
    CANNON_ICON: 0xFFD700, CANNON_BALL: 0xFFFF00, 
    EXPLOSION: 0xFF4500, TRAIL_COLOR: 0xFF6600, TRAIL_BASE: 0xFFFFFF 
};

const gameConfig = {
    type: Phaser.AUTO, 
    scale: { mode: Phaser.Scale.FIT, autoCenter: Phaser.Scale.CENTER_BOTH, width: 540, height: 960 },
    parent: 'game-container',
    backgroundColor: '#f7ce65',
    physics: { default: 'arcade', arcade: { debug: false, gravity: { y: 0 }, fps: 60 } },
    fps: { target: 60, min: 30 },
    scene: { preload: preload, create: create, update: update },
    pixelArt: true
};

const game = new Phaser.Game(gameConfig);

// Globals
let player, directionArrow;
let playerShadow; 
let wheelLeft, wheelRight, wheelLeftShadow, wheelRightShadow;
let wheelsGroup; 
let cursors, joystickBase, joystickStick;
let isTouching = false, touchStartPoint = { x: 0, y: 0 };
let enemies, bullets, pickups, boomerangs;
let explosionEmitter; 
let debugGraphics; 
let hitboxGraphics; 

let isDebugMode = false;
let gameStarted = false;
let startLogo, startText;

let lastWheelPosLeft = null;
let lastWheelPosRight = null;

let turretSlotsDef = [
    { x: 0,   y: -106 }, 
    { x: -60, y: -50 }, 
    { x: 60,  y: -50 }, 
    { x: -60, y: 44 }, 
    { x: 60,  y: 44 }, 
    { x: 0,   y: 106 } 
];

let turretSlots = []; 
let activeTurrets = [];
let score = 0, gameTime = 60, hp = 100, maxHp = 100;
let recentDamageStreak = 0, recentDamageLastAt = 0, recentDamageWindowUntil = 0;
let powerupsCollected = 0; // counts POWERUP pickups for damage reduction
let highScore = 0;
let targetLetters = "HAPPYNEWYEAR".split('');
let collectedIndices = [];
let droppedLetterIndices = [];
let letterBonusFlags = { happy:false, new:false, year:false, all:false }; 
let damagePerShot = 1; 
let droppedCounts = { powerup: 0, heart: 0 };
let comboCount = 0;
let comboTimerEvent = null;
// UI Elements
let timeText, timeDigitTens, timeDigitOnes, hpText, scoreText, highScoreText, letterText, fpsText, debugText;
let hudBg = null;
let uiIntroTargets = null;
let clockIcon, hpIcon;

let hnyHudSprites = null;
let comboText, comboScaleTween; 
let gameOver = false;
let shipDestroyedSequence = false;
let winSequence = false;

let timerEvent, fireEvent;
let boomerangGlobalAngle = 0;

function preload() {
    this.load.spritesheet('zombie_sheet', 'assets/zombie.png', { frameWidth: 128, frameHeight: 128 });
    this.load.image('playerTex', 'assets/boat.png');
    this.load.image('arrowTex', 'assets/arrowred.png');
    this.load.spritesheet('explosion8', 'assets/ark_explosion.png', { frameWidth: 128, frameHeight: 128 });
    this.load.spritesheet('hnyLetters', 'assets/text_happynewyear.png', { frameWidth: 110, frameHeight: 128 });
    this.load.spritesheet('countdownNumbers', 'assets/text_number.png', { frameWidth: 110, frameHeight: 128 });
    this.load.image('questionMark', 'assets/text_question.png');
    this.load.image('textPowerup', 'assets/text_powerup.png');
    this.load.image('textHP', 'assets/text_HP+.png');
    this.load.spritesheet('wheelAnim', 'assets/wheel_anim.png', { frameWidth: 256, frameHeight: 345 });
    this.load.spritesheet('powerupSheet', 'assets/powup_anim.png', { frameWidth: 89, frameHeight: 89 });
    this.load.spritesheet('heartSheet', 'assets/heart_anim.png', { frameWidth: 89, frameHeight: 89 });
    this.load.image('wheelShadowTex', 'assets/wheel_shadow.png');
    this.load.spritesheet('gun8dir', 'assets/machinegun.png', { frameWidth: 128, frameHeight: 128 });
    this.load.spritesheet('cannon8dir', 'assets/cannon.png', { frameWidth: 128, frameHeight: 128 });
    this.load.spritesheet('boomerang8dir', 'assets/boomerang.png', { frameWidth: 128, frameHeight: 128 });
    this.load.image('boomerangProjectile', 'assets/boomerang_projectile.png');
    this.load.image('boomerangShadowTex', 'assets/boomerang_projectile_shadow.png');
    this.load.image('bulletTex', 'assets/bullet.png');
    this.load.image('cannonBallTex', 'assets/bomb.png');
    this.load.spritesheet('explosionAnim', 'assets/explosion.png', { frameWidth: 128, frameHeight: 128 });
    this.load.spritesheet('zombie_death', 'assets/zombie_death.png', { frameWidth: 128, frameHeight: 128 });
    this.load.image('gameLogo', 'assets/logo.png');
    this.load.spritesheet('groundTiles', 'assets/tiles.png', { frameWidth: 128, frameHeight: 128 });
    this.load.image('playerShadowTex', 'assets/shadow.png');
    this.load.image('trackTex', 'assets/track.png');
    
    // Add custom clock icon (or auto-generated later if not found)
    // this.load.image('clockIcon', 'assets/clock.png'); // Uncomment if file exists
}

function setActionLog(msg) {
    if(debugText) debugText.lastAction = msg;
}

function loadHighScore() {
    try {
        const saved = localStorage.getItem('zr_highscore');
        if (saved) highScore = parseInt(saved, 10);
    } catch (e) {}
}

function saveHighScore(newScore) {
    if (newScore > highScore) {
        highScore = newScore;
        try { localStorage.setItem('zr_highscore', highScore); } catch (e) {}
    }
}

function create() {
    loadHighScore();
    setupDomEvents();
    generateTextures(this); 
    
    createZombieAnimations(this);

    if (!this.anims.exists('explosion_play')) {
        this.anims.create({
            key: 'explosion_play',
            frames: this.anims.generateFrameNumbers('explosion8', { start: 0, end: 7 }),
            frameRate: 14,
            repeat: 0
        });
    }

    const spinFrames = [1, 2, 5, 8, 7, 6, 3, 0];
    this.anims.create({ key: 'spin_gun', frames: this.anims.generateFrameNumbers('gun8dir', { frames: spinFrames }), frameRate: 6, repeat: -1 });
    this.anims.create({ key: 'spin_cannon', frames: this.anims.generateFrameNumbers('cannon8dir', { frames: spinFrames }), frameRate: 6, repeat: -1 });
    this.anims.create({ key: 'spin_boomerang', frames: this.anims.generateFrameNumbers('boomerang8dir', { frames: spinFrames }), frameRate: 6, repeat: -1 });
    this.anims.create({ key: 'spin_powerup', frames: this.anims.generateFrameNumbers('powerupSheet', { frames: [0,1,2,3,5,6,7,8] }), frameRate: 6, repeat: -1 });
    this.anims.create({ key: 'spin_heart', frames: this.anims.generateFrameNumbers('heartSheet', { frames: [0,1,2,3,5,6,7,8] }), frameRate: 6, repeat: -1 });

    this.anims.create({
        key: 'wheel_roll',
        frames: this.anims.generateFrameNumbers('wheelAnim', { start: 0, end: 2 }),
        frameRate: 15,
        repeat: -1
    });

    this.anims.create({
        key: 'explode',
        frames: this.anims.generateFrameNumbers('explosionAnim', { start: 0, end: 35 }),
        frameRate: 60,
        hideOnComplete: true
    });

    this.physics.world.setBounds(0, 0, 2000, 2000);
    this.cameras.main.setBounds(0, 0, 2000, 2000);
    
    for (let i = 0; i < 16; i++) {
        const x = Phaser.Math.Between(0, 2000);
        const y = Phaser.Math.Between(0, 2000);
        const frame = Phaser.Math.Between(0, 15);
        const decor = this.add.sprite(x, y, 'groundTiles', frame);
        decor.setDepth(-1); 
    }

    const WHEEL_SCALE_FIX = 0.6; 
    const finalWheelScale = WHEEL_SCALE_FIX * CONFIG.PLAYER_SCALE;

    wheelsGroup = this.physics.add.group();

    wheelLeftShadow = this.add.sprite(1000, 1000, 'wheelShadowTex').setDepth(2);
    wheelLeftShadow.setFlipX(true);
    wheelLeftShadow.setScale(finalWheelScale);
    wheelLeftShadow.alpha = 0.5;

    wheelRightShadow = this.add.sprite(1000, 1000, 'wheelShadowTex').setDepth(2);
    wheelRightShadow.setFlipX(false);
    wheelRightShadow.setScale(finalWheelScale);
    wheelRightShadow.alpha = 0.5;

    wheelLeft = this.physics.add.sprite(1000, 1000, 'wheelAnim').setDepth(9);
    wheelLeft.setFlipX(true); 
    wheelLeft.setScale(finalWheelScale); 
    wheelLeft.body.setSize(180, 280); 
    wheelsGroup.add(wheelLeft);

    wheelRight = this.physics.add.sprite(1000, 1000, 'wheelAnim').setDepth(9);
    wheelRight.setFlipX(false);
    wheelRight.setScale(finalWheelScale);
    wheelRight.body.setSize(180, 280); 
    wheelsGroup.add(wheelRight);

    playerShadow = this.add.sprite(1000, 1000, 'playerShadowTex');
    playerShadow.setDepth(2);
    playerShadow.setScale(CONFIG.PLAYER_SCALE); 
    playerShadow.alpha = 0.5;

    player = this.physics.add.sprite(1000, 1000, 'playerTex');
    player.setScale(CONFIG.PLAYER_SCALE);
    player.rotation = -Math.PI / 2; 

    lastWheelPosLeft = new Phaser.Math.Vector2(wheelLeft.x, wheelLeft.y);
    lastWheelPosRight = new Phaser.Math.Vector2(wheelRight.x, wheelRight.y);

    turretSlots = turretSlotsDef.map(slot => ({
        x: slot.x * CONFIG.PLAYER_SCALE,
        y: slot.y * CONFIG.PLAYER_SCALE,
        occupied: false,
        sprite: null
    }));

    const bodyW = 140 * CONFIG.PLAYER_SCALE; 
    const bodyH = 300 * CONFIG.PLAYER_SCALE; 
    player.body.setSize(bodyW, bodyH); 
    
    player.setCollideWorldBounds(true);
    player.setDepth(10);
    
    this.cameras.main.startFollow(player, true, 0.1, 0.1);
    this.cameras.main.setZoom(0.8);

    if (DEBUG_SLOTS) {
        debugGraphics = this.add.graphics().setDepth(100);
    }
    hitboxGraphics = this.add.graphics().setDepth(1000);
    setupDebugBtn(this);

    directionArrow = this.add.sprite(player.x, player.y, 'arrowTex').setDepth(20).setVisible(false);
    directionArrow.rotation = -Math.PI / 2;
    directionArrow._dirAngle = -Math.PI / 2;   // 默认朝上（静止时）

    enemies = this.physics.add.group({ runChildUpdate: false, bounceX: 0, bounceY: 0, dragX: 500, dragY: 500 }); 
    this.physics.add.collider(enemies, enemies);

    bullets = this.physics.add.group({ defaultKey: 'bulletTex', maxSize: 800, runChildUpdate: false });
    boomerangs = this.physics.add.group({ runChildUpdate: false, allowGravity: false, immovable: true });
    pickups = this.physics.add.group();

    this.physics.add.collider(enemies, pickups, null, (enemy, pickup) => {
        return pickup.dropType === 'TURRET' && !pickup.isMagneting;
    });

    explosionEmitter = this.add.particles(0, 0, 'bulletTex', {
        lifespan: 300, speed: { min: 100, max: 200 }, scale: { start: 1, end: 0 },
        quantity: 8, emitting: false 
    });
    explosionEmitter.setDepth(15);

    cursors = this.input.keyboard.createCursorKeys();
    this.input.keyboard.addKeys('W,A,S,D');
    this.input.addPointer(1);
    setupVirtualJoystick(this);

    addTurret(this);
    createUI(this);

    this.physics.add.overlap(bullets, enemies, hitEnemy, null, this);
    this.physics.add.overlap(boomerangs, enemies, hitEnemyByBoomerang, null, this);
    this.physics.add.overlap(player, enemies, handleTrample, null, this);
    this.physics.add.overlap(wheelsGroup, enemies, handleTrample, null, this);
    this.physics.add.overlap(player, pickups, collectPickup, null, this);

    gameStarted = false;
    createStartScreen(this);

    // ===========================================
    // 【修复】移动端音频解锁代码
    // 监听第一次点击/触摸，强制唤醒 AudioContext
    // ===========================================
    this.input.once('pointerdown', () => {
        try {
            // 1. 初始化/恢复 WebAudio Context (SFX)
            SFX.init();
            
            // 2. 尝试预热 BGM (HTML Audio)
            // 即使逻辑还没让它开始放，先 play() 一下让浏览器给权限
            const bgmEl = document.getElementById('bgm');
            if (bgmEl) {
                // 试图播放，如果被逻辑打断也没关系，重点是获取权限
                const p = bgmEl.play();
                if (p && typeof p.catch === 'function') {
                    p.catch(e => console.log("BGM unlock attempt caught (normal):", e));
                }
            }
        } catch (e) {
            console.log("Audio unlock failed:", e);
        }
    });
}



function createStartScreen(scene) {
    const screenWidth = scene.cameras.main.width;
    const screenHeight = scene.cameras.main.height;
    startLogo = scene.add.sprite(screenWidth / 2, screenHeight * 0.15, 'gameLogo');
    startLogo.setScrollFactor(0);
    startLogo.setDepth(1000);
    startLogo.displayWidth = screenWidth * 1.05;
    startLogo.scaleY = startLogo.scaleX; 
    const isDesktop = scene.sys.game.device.os.desktop;
    const textStr = isDesktop
        ? "Move with W/A/S/D \nor \ndrag the mouse"
        : "Ready? Drag to go!";
    startText = scene.add.text(screenWidth / 2, screenHeight * 0.70, textStr, {
        fontSize: '21px',
        fontFamily: 'Press Start 2P',
        fontStyle: 'bold',
        color: '#FFFFFF',
        //stroke: '#000000',
        //strokeThickness: 4,
        align: 'center'
    }).setOrigin(0.5).setScrollFactor(0).setDepth(1000).setScale(0.9);


    if (document.fonts && document.fonts.ready) {
        document.fonts.ready.then(() => {
        if (!startText || !startText.active) return;
        startText.setFontFamily('"Press Start 2P"'); // 强制一次
        startText.setText(startText.text);           // 触发重建贴图
        if (startText.updateText) startText.updateText(); // Phaser Text: 强制刷新（有则调用）
    });
}

    scene.tweens.add({ targets: startText, alpha: 0.5, duration: 800, yoyo: true, repeat: -1 });
}

function startGameLogic(scene) {
    if (gameStarted) return;
    gameStarted = true;
    
    try { SFX.init();
        try { if (window.SFX && window.SFX.ui_start) window.SFX.ui_start(); } catch(e) {}
        BGM.start(); SFX.ui_click(); } catch (e) {}
scene.tweens.add({ targets: startText, alpha: 0, duration: 300, onComplete: () => startText.destroy() });
    scene.tweens.add({ targets: startLogo, y: -200, duration: 1000, ease: 'Back.in', onComplete: () => startLogo.setVisible(false) });
    scene.time.delayedCall(1000, () => runHUDIntro(scene));
spawnZombieWave(scene);
    timerEvent = scene.time.addEvent({ delay: 1000, callback: updateTimer, callbackScope: scene, loop: true });
    fireEvent = scene.time.addEvent({ delay: CONFIG.FIRE_RATE, callback: fireTurrets, callbackScope: scene, loop: true });
}

function checkGameStart(scene) {
    const keys = scene.input.keyboard.createCursorKeys();
    const wasd = scene.input.keyboard.addKeys('W,A,S,D');
    const anyKeyPress = keys.left.isDown || keys.right.isDown || keys.up.isDown || keys.down.isDown ||
                        wasd.W.isDown || wasd.A.isDown || wasd.S.isDown || wasd.D.isDown;
    const pointerDown = scene.input.activePointer.isDown;
    if (anyKeyPress || pointerDown) {
        startGameLogic(scene);
    }
}

function createZombieAnimations(scene) {
    const frameRate = 8;
    scene.anims.create({ key: 'z_down', frames: scene.anims.generateFrameNumbers('zombie_sheet', { frames: [0, 4, 8, 12] }), frameRate: frameRate, repeat: -1 });
    scene.anims.create({ key: 'z_up', frames: scene.anims.generateFrameNumbers('zombie_sheet', { frames: [1, 5, 9, 13] }), frameRate: frameRate, repeat: -1 });
    scene.anims.create({ key: 'z_left', frames: scene.anims.generateFrameNumbers('zombie_sheet', { frames: [2, 6, 10, 14] }), frameRate: frameRate, repeat: -1 });
    scene.anims.create({ key: 'z_right', frames: scene.anims.generateFrameNumbers('zombie_sheet', { frames: [3, 7, 11, 15] }), frameRate: frameRate, repeat: -1 });
    scene.anims.create({ key: 'death_1', frames: scene.anims.generateFrameNumbers('zombie_death', { start: 0, end: 3 }), frameRate: 7, repeat: 0 });
    scene.anims.create({ key: 'death_2', frames: scene.anims.generateFrameNumbers('zombie_death', { start: 4, end: 7 }), frameRate: 7, repeat: 0 });
}

function setupDebugBtn(scene) {
    const debugBtn = document.getElementById('debug-btn');
    if (debugBtn) {
        const newBtn = debugBtn.cloneNode(true);
        debugBtn.parentNode.replaceChild(newBtn, debugBtn);
        newBtn.addEventListener('click', () => {
            isDebugMode = !isDebugMode;
            newBtn.innerText = `DEBUG: ${isDebugMode ? 'ON' : 'OFF'}`;
            newBtn.style.color = isDebugMode ? '#00FF00' : '#888';
            newBtn.style.borderColor = isDebugMode ? '#00FF00' : '#888';
            scene.physics.world.drawDebug = isDebugMode;
            if (!scene.physics.world.debugGraphic) {
                scene.physics.world.createDebugGraphic();
            }
            scene.physics.world.debugGraphic.clear(); 
        });
    }
}

function setupDomEvents() {
    const restartBtn = document.getElementById('restart-btn');
    if (restartBtn) {
        const newBtn = restartBtn.cloneNode(true);
        restartBtn.parentNode.replaceChild(newBtn, restartBtn);
        newBtn.addEventListener('click', async () => {
            const nameInput = document.getElementById('player-name-input');
            const typed = (nameInput && nameInput.value) ? nameInput.value.trim() : "";
            let saved = "";
            try { saved = (localStorage.getItem('zr_player_name') || localStorage.getItem('lb_name') || "").trim(); } catch(e){}
            const finalName = typed || saved;
            if (!finalName) {
                try {
                    if (nameInput) { nameInput.focus(); }
                    const st = document.getElementById('lb-status');
                    if (st) st.textContent = "Enter your name to save score.";
                } catch(e){}
                return;
            }
            if (typed) {
                try { localStorage.setItem('zr_player_name', typed); } catch(e){}
            }
            try {
                const api = window.LeaderboardAPI;
                if (api && typeof api.beforePlayAgain === 'function') {
                    await Promise.race([
                        api.beforePlayAgain(),
                        new Promise(res => setTimeout(res, 1200))
                    ]);
                }
            } catch(e){}
            location.reload();
        });
    }
}

function update(time, delta) {
    if (gameOver) return;
    updateVisuals(time);
    if (!gameStarted) {
        checkGameStart(this);
        return;
    }
    handlePlayerMovement(this, time);
    handlePickupsMagnet(this);
    updateWheelTrack(this, wheelLeft, lastWheelPosLeft);
    updateWheelTrack(this, wheelRight, lastWheelPosRight);

    enemies.getChildren().forEach(enemy => {
        if (!enemy.active) return;
        if (enemy.shadow && enemy.shadow.active) {
            enemy.shadow.setPosition(enemy.x, enemy.y + 20); 
        }
        if (enemy.isDying) return;
        const angle = Phaser.Math.Angle.Between(enemy.x, enemy.y, player.x, player.y);
        const deg = Phaser.Math.RadToDeg(angle);
        if (deg > -45 && deg <= 45) enemy.play('z_right', true);
        else if (deg > 45 && deg <= 135) enemy.play('z_down', true);
        else if (deg > -135 && deg <= -45) enemy.play('z_up', true);
        else enemy.play('z_left', true);

        if (enemy.stunUntil && time < enemy.stunUntil) { } else {
            this.physics.moveTo(enemy, player.x, player.y, enemy.speed);
        }
    });

    if (isDebugMode) {
        if (hitboxGraphics) {
            hitboxGraphics.clear();
            if (player.body) {
                hitboxGraphics.fillStyle(0x00FF00, 0.6); 
                hitboxGraphics.fillRect(player.body.x, player.body.y, player.body.width, player.body.height);
            }
            hitboxGraphics.fillStyle(0x00FFFF, 0.6);
            if (wheelLeft.body) hitboxGraphics.fillRect(wheelLeft.body.x, wheelLeft.body.y, wheelLeft.body.width, wheelLeft.body.height);
            if (wheelRight.body) hitboxGraphics.fillRect(wheelRight.body.x, wheelRight.body.y, wheelRight.body.width, wheelRight.body.height);
        }
    } else {
        if (hitboxGraphics) hitboxGraphics.clear();
        if (debugGraphics) debugGraphics.clear();
    }
    
    // MODIFIED: Update HUD Text
    hpText.setText(`x${Math.max(0,Math.floor(hp))}`); 
    
    // Zero-pad the score to 6 digits (e.g. 000123)
    let sStr = String(score).padStart(6, '0');
    scoreText.setText(`SCORE: ${sStr}`);

    updateDebugInfo();
}

function updateWheelTrack(scene, wheel, lastPosVec) {
    const dist = Phaser.Math.Distance.Between(lastPosVec.x, lastPosVec.y, wheel.x, wheel.y);
    const step = 8; 
    if (dist > step) {
        let count = Math.floor(dist / step);
        const angle = Math.atan2(wheel.y - lastPosVec.y, wheel.x - lastPosVec.x);
        for (let i = 0; i < count; i++) {
            lastPosVec.x += Math.cos(angle) * step;
            lastPosVec.y += Math.sin(angle) * step;
            spawnTireTrack(scene, lastPosVec.x, lastPosVec.y, angle);
        }
    }
}

function spawnTireTrack(scene, x, y, angleRad) {
    const track = scene.add.sprite(x, y, 'trackTex');
    track.setDepth(0); 
    track.setRotation(angleRad + Math.PI / 2); 
    track.setScale(1.2); 
    track.alpha = 0.6; 
    scene.tweens.add({ targets: track, alpha: 0, duration: 10000, onComplete: () => track.destroy() });
}

function updateDebugInfo() {
    // MODIFIED: Debug info removed
    if(!debugText) return;
}

function handlePickupsMagnet(scene) {
    pickups.getChildren().forEach(drop => {
        if (!drop.active) return;
        if (drop.shadow && drop.shadow.active) {
            drop.shadow.setPosition(drop.x, drop.y + 25);
        }
        if (drop.dropType === 'LETTER') return;
        if (!drop.canMagnet) return;
        const dist = Phaser.Math.Distance.Between(drop.x, drop.y, player.x, player.y);
        if (dist <= CONFIG.MAGNET_DIST && !drop.isMagneting) {
            drop.isMagneting = true;
            scene.tweens.killTweensOf(drop); 
        }
        if (drop.isMagneting) {
            scene.physics.moveToObject(drop, player, CONFIG.MAGNET_SPEED);
        }
    });
}

function updateVisuals(time) {
const isMoving = player.body.velocity.length() > 10;

if (isMoving) {
    const dir = player.body.velocity.angle();

    directionArrow.setScale(1.4);


    // 箭头放在前方的距离（可微调）
    const dist = 180 * CONFIG.PLAYER_SCALE;

    directionArrow.x = player.x + Math.cos(dir) * dist;
    directionArrow.y = player.y + Math.sin(dir) * dist;

    directionArrow.setVisible(true);

    // 旋转：如果你的 arrowred.png 是“朝上”的箭头，用 +Math.PI/2
    // 如果发现方向不对，改成 0 / -Math.PI/2 / Math.PI 试一下
    directionArrow.setRotation(dir + Math.PI / 2);

    // 存一个“纯方向”，避免影响下面的 angle 逻辑
    directionArrow._dirAngle = dir;
} else {
    directionArrow.setVisible(false);
    directionArrow.x = player.x;
    directionArrow.y = player.y;
}

let angle = isMoving ? player.body.velocity.angle() : (directionArrow._dirAngle || 0);

    
    if (isMoving) {
        if (wheelLeft.anims.currentAnim?.key !== 'wheel_roll' || !wheelLeft.anims.isPlaying) {
            wheelLeft.play('wheel_roll');
            wheelRight.play('wheel_roll');
        }
    } else {
        if (wheelLeft.anims.isPlaying) {
            wheelLeft.stop();
            wheelRight.stop();
        }
    }

    let suspensionOffset = isMoving ? Math.sin(time * 0.02) * 3 : 0;
    const sideDist = 100 * CONFIG.PLAYER_SCALE; 
    
    const cosA = Math.cos(angle);
    const sinA = Math.sin(angle);
    
    wheelLeft.x = player.x + ((-suspensionOffset) * cosA - (-sideDist) * sinA);
    wheelLeft.y = player.y + ((-suspensionOffset) * sinA + (-sideDist) * cosA);
    wheelLeft.rotation = angle + Math.PI / 2; 

    wheelRight.x = player.x + ((suspensionOffset) * cosA - (sideDist) * sinA);
    wheelRight.y = player.y + ((suspensionOffset) * sinA + (sideDist) * cosA);
    wheelRight.rotation = angle + Math.PI / 2;

    wheelLeftShadow.x = wheelLeft.x;
    wheelLeftShadow.y = wheelLeft.y + 10;
    wheelLeftShadow.rotation = wheelLeft.rotation;

    wheelRightShadow.x = wheelRight.x;
    wheelRightShadow.y = wheelRight.y + 10;
    wheelRightShadow.rotation = wheelRight.rotation;

    const isHorizontal = Math.abs(Math.sin(wheelLeft.rotation)) > 0.707;
    const wVert = 180;
    const hVert = 280;
    if (isHorizontal) {
        if (wheelLeft.body.width !== hVert) {
            wheelLeft.body.setSize(hVert, wVert, true);
            wheelRight.body.setSize(hVert, wVert, true);
        }
    } else {
        if (wheelLeft.body.width !== wVert) {
            wheelLeft.body.setSize(wVert, hVert, true);
            wheelRight.body.setSize(wVert, hVert, true);
        }
    }
    
    player.rotation = isMoving ? Math.sin(time * 0.025) * 0.03 : 0;
    playerShadow.x = player.x; 
    playerShadow.y = player.y + 10; 
    playerShadow.rotation = player.rotation; 

    const rads = player.rotation;
    const cR = Math.cos(rads);
    const sR = Math.sin(rads);

    if (isDebugMode && debugGraphics) {
        debugGraphics.clear();
        debugGraphics.fillStyle(0x00FF00, 0.8);
        turretSlots.forEach(slot => {
            const rx = slot.x * cR - slot.y * sR;
            const ry = slot.x * sR + slot.y * cR;
            debugGraphics.fillCircle(player.x + rx, player.y + ry, 5);
        });
    }

    let validTargets = enemies.getChildren().filter(e => e.active && !e.isDying && Phaser.Math.Distance.Between(player.x, player.y, e.x, e.y) < 700);
    validTargets.sort((a, b) => {
        const distA = Phaser.Math.Distance.Between(player.x, player.y, a.x, a.y);
        const distB = Phaser.Math.Distance.Between(player.x, player.y, b.x, b.y);
        return distA - distB;
    });

    activeTurrets.forEach((tInfo, index) => {
        const turret = tInfo.sprite;
        const rx = tInfo.offsetX * cR - tInfo.offsetY * sR;
        const ry = tInfo.offsetX * sR + tInfo.offsetY * cR;
        
        turret.x = player.x + rx;
        turret.y = player.y + ry;

        if (tInfo.type === 'GUN' || tInfo.type === 'CANNON' || tInfo.type === 'BOOMERANG') {
            let target = null;
            if (tInfo.type === 'GUN' && validTargets.length > 0) {
                target = validTargets[index % validTargets.length];
                tInfo.hasTarget = true;
            } else if ((tInfo.type === 'CANNON' || tInfo.type === 'BOOMERANG') && validTargets.length > 0) {
                target = validTargets[0];
                tInfo.hasTarget = true;
                tInfo.targetEntity = target;
            } else {
                tInfo.hasTarget = false;
                tInfo.targetEntity = null;
            }

            if (tInfo.hasTarget && target) {
                tInfo.targetAngle = Phaser.Math.Angle.Between(turret.x, turret.y, target.x, target.y);
                const deg = Phaser.Math.RadToDeg(tInfo.targetAngle);
                let frameIndex = 7; 
                if (deg >= -22.5 && deg < 22.5) frameIndex = 5;       
                else if (deg >= 22.5 && deg < 67.5) frameIndex = 8;   
                else if (deg >= 67.5 && deg < 112.5) frameIndex = 7;  
                else if (deg >= 112.5 && deg < 157.5) frameIndex = 6; 
                else if (deg >= 157.5 || deg < -157.5) frameIndex = 3;
                else if (deg >= -157.5 && deg < -112.5) frameIndex = 0;
                else if (deg >= -112.5 && deg < -67.5) frameIndex = 1;
                else if (deg >= -67.5 && deg < -22.5) frameIndex = 2; 
                turret.setFrame(frameIndex);
                turret.rotation = 0; 
            } else {
                turret.setFrame(7); 
            }
        }
    });

    boomerangGlobalAngle += CONFIG.BOOMERANG_SPEED;
    boomerangs.getChildren().forEach(b => {
        if (!b.active) return;
        let currentAngle = boomerangGlobalAngle + b.phaseOffset;
        let radius = b.orbitRadius || CONFIG.BOOMERANG_RADIUS;
        b.x = player.x + Math.cos(currentAngle) * radius;
        b.y = player.y + Math.sin(currentAngle) * radius;
        b.rotation += 0.4; 
        if (b.shadowSprite) {
            b.shadowSprite.setPosition(b.x, b.y + 30);
            b.shadowSprite.setRotation(b.rotation);
        }
    });
}

function spawnZombieWave(scene) {
    if (gameOver || winSequence) return;
    const progress = (60 - gameTime) / 60; 
    let count = Phaser.Math.Between(2, 10);
    let nextDelay = 1000 - (progress * 600); 
    const cam = scene.cameras.main;
    const padding = 50; 
    const view = cam.worldView;
    let centerX, centerY;
    const side = Phaser.Math.Between(0, 3);
    if (side === 0) { centerX = Phaser.Math.Between(view.x, view.right); centerY = view.y - padding; } 
    else if (side === 1) { centerX = Phaser.Math.Between(view.x, view.right); centerY = view.bottom + padding; } 
    else if (side === 2) { centerX = view.x - padding; centerY = Phaser.Math.Between(view.y, view.bottom); } 
    else { centerX = view.right + padding; centerY = Phaser.Math.Between(view.y, view.bottom); }

    for(let i=0; i<count; i++) {
        const offsetX = Phaser.Math.Between(-80, 80);
        const offsetY = Phaser.Math.Between(-80, 80);
        createOneEnemy(scene, centerX + offsetX, centerY + offsetY);
    }
    setActionLog(`Spawn Wave (${count})`);
    scene.time.delayedCall(nextDelay, () => spawnZombieWave(scene));
}

function createOneEnemy(scene, x, y) {
    const enemy = enemies.create(x, y, 'zombie_sheet');
    if(enemy) {
        const elapsed = 60 - gameTime;
        enemy.speed = CONFIG.SPEED_ZOMBIE_BASE + elapsed;
        enemy.hp = CONFIG.HP_ZOMBIE_BASE + Math.floor(elapsed * 1.2);
        enemy.setCircle(55, 9, 9); 
        enemy.setCollideWorldBounds(false); 
        enemy.setDepth(5);
        enemy.lastBoomerangHit = 0;
        enemy.stunUntil = 0; 
        enemy.setScale(0.4);
        enemy.isDying = false; 
        enemy.shadow = scene.add.sprite(x, y, 'shadowTex');
        enemy.shadow.setDepth(2);
        enemy.shadow.setScale(1.2, 0.4); 
        enemy.shadow.alpha = 0.4;
    }
}

function addTurret(scene, specificType = null) {
    const slotIndex = turretSlots.findIndex(s => !s.occupied);
    if (slotIndex === -1) return; 
    const slot = turretSlots[slotIndex];
    slot.occupied = true;
    let type = specificType;
    if (!type) {
        if (activeTurrets.length === 0) type = 'GUN';
        else {
            const rand = Math.random();
            if (rand < 0.33) type = 'GUN';
            else if (rand < 0.66) type = 'BOOMERANG';
            else type = 'CANNON';
        }
    }
    let textureKey;
    if (type === 'GUN') textureKey = 'gun8dir'; 
    else if (type === 'BOOMERANG') textureKey = 'boomerang8dir';
    else if (type === 'CANNON') textureKey = 'cannon8dir';
    
    const tSprite = scene.add.sprite(player.x, player.y, textureKey);
    tSprite.setDepth(11);
    if (type === 'GUN') { tSprite.setScale(0.5 * CONFIG.PLAYER_SCALE); }
    else if (type === 'CANNON') { tSprite.setScale(0.5 * CONFIG.PLAYER_SCALE); }
    else if (type === 'BOOMERANG') { tSprite.setScale(0.5 * CONFIG.PLAYER_SCALE); }
    else { tSprite.setScale(1.0); }
    let turretData = { type: type, sprite: tSprite, offsetX: slot.x, offsetY: slot.y, hasTarget: false, targetEntity: null, targetAngle: 0, lastFired: 0 };
    activeTurrets.push(turretData);
    if (type === 'BOOMERANG') spawnBoomerangProjectiles(scene);
    setActionLog("Installed " + type);
}

function spawnBoomerangProjectiles(scene) {
    let baseOffset = Math.random() * Math.PI * 2;
    const radiusMultipliers = [0.7, 1.0, 1.3];
    for(let i=0; i<3; i++) {
        let b = boomerangs.create(player.x, player.y, 'boomerangProjectile');
        b.setDepth(20); b.setCircle(45); 
        b.phaseOffset = baseOffset + (i * (Math.PI * 2 / 3));
        b.orbitRadius = CONFIG.BOOMERANG_RADIUS * radiusMultipliers[i]; 
        b.setScale(1.2); 
        let shadow = scene.add.sprite(0, 0, 'boomerangShadowTex');
        shadow.setDepth(8); shadow.setScale(1.2); shadow.setAlpha(0.5);
        b.shadowSprite = shadow;
    }
}

function fireTurrets() {
    if (gameOver) return;
    const now = game.loop.now;
    activeTurrets.forEach(tInfo => {
        if (tInfo.type === 'GUN' && tInfo.hasTarget) {
            const b = bullets.get(tInfo.sprite.x, tInfo.sprite.y);
            if (b) {
                b.setActive(true).setVisible(true);
                b.body.enable = true;
                b.setDepth(20);
                b.rotation = tInfo.targetAngle; 
                this.physics.velocityFromRotation(tInfo.targetAngle, CONFIG.BULLET_SPEED, b.body.velocity);
                b.setScale(0.25);
                b.body.updateFromGameObject();
                this.time.delayedCall(1500, () => { if(b.active) b.setActive(false).setVisible(false).body.enable = false; });
            }
        }
        else if (tInfo.type === 'CANNON' && tInfo.hasTarget) {
            if (now - tInfo.lastFired > 1500) {
                tInfo.lastFired = now;
                fireCannonBall(tInfo);
            }
        }
    });
}

function fireCannonBall(tInfo) {
    if (!tInfo.targetEntity || !tInfo.targetEntity.active) return;
    const scene = tInfo.sprite.scene;
    const ball = scene.add.sprite(tInfo.sprite.x, tInfo.sprite.y, 'cannonBallTex');
    ball.setDepth(25); ball.setScale(0.5); 
    scene.tweens.add({ targets: ball, angle: 720, duration: 750 }); 
    const target = tInfo.targetEntity;
    const tx = target.x; const ty = target.y;
    const dist = Phaser.Math.Distance.Between(ball.x, ball.y, tx, ty);
    const duration = Phaser.Math.Clamp(dist * 2, 500, 750); 
    const emitter = scene.add.particles(0, 0, 'trailTex', {
        speed: 0, lifespan: 300, scale: { start: 3.0, end: 0 }, alpha: { start: 0.8, end: 0 },
        quantity: 2, frequency: 20, blendMode: 'ADD', tint: COLORS.TRAIL_COLOR 
    });
    emitter.startFollow(ball); emitter.setDepth(24);
    scene.tweens.add({
        targets: ball, x: tx, y: ty, duration: duration, ease: 'Linear',
        onComplete: () => {
            emitter.stop(); scene.time.delayedCall(500, () => emitter.destroy());
            explodeCannonBall(scene, tx, ty); ball.destroy();
        }
    });
    scene.tweens.add({ targets: ball, scaleX: 1.2, scaleY: 1.2, duration: duration / 2, yoyo: true, ease: 'Sine.easeOut' });
}

function explodeCannonBall(scene, x, y) {
    const explosion = scene.add.sprite(x, y, 'explosionAnim');
    explosion.setDepth(30); explosion.setScale(2.5); explosion.play('explode');
    explosion.once('animationcomplete', () => { explosion.destroy(); });
    if (isDebugMode) {
        const debugCircle = scene.add.circle(x, y, CONFIG.CANNON_AOE_RADIUS);
        debugCircle.setStrokeStyle(2, 0x00FF00); debugCircle.setDepth(1001);
        scene.tweens.add({ targets: debugCircle, alpha: 0, duration: 1000, onComplete: () => debugCircle.destroy() });
    }
    enemies.getChildren().forEach(enemy => {
        if (!enemy.active) return;
        const dist = Phaser.Math.Distance.Between(x, y, enemy.x, enemy.y);
        if (dist <= CONFIG.CANNON_AOE_RADIUS) {
            enemy.hp -= CONFIG.DAMAGE_CANNON;
            enemy.setTintFill(0xff0000); 
            scene.time.delayedCall(100, () => { if(enemy.active) enemy.clearTint(); });
            const angle = Phaser.Math.Angle.Between(x, y, enemy.x, enemy.y);
            scene.physics.velocityFromRotation(angle, CONFIG.CANNON_KNOCKBACK, enemy.body.velocity);
            enemy.stunUntil = scene.time.now + CONFIG.CANNON_STUN_DURATION;
            if (enemy.hp <= 0) killEnemy(enemy);
        }
    });
}

function handlePlayerMovement(scene, time) {
    if (shipDestroyedSequence) { try { player.setVelocity(0); } catch (e) {} return; }
    player.setVelocity(0);
    let vx = 0, vy = 0;
    let keys = scene.input.keyboard.addKeys('W,A,S,D');
    if (cursors.left.isDown || keys.A.isDown) vx = -1; else if (cursors.right.isDown || keys.D.isDown) vx = 1;
    if (cursors.up.isDown || keys.W.isDown) vy = -1; else if (cursors.down.isDown || keys.S.isDown) vy = 1;
    if (isTouching) {
        let dx = scene.input.activePointer.x - touchStartPoint.x;
        let dy = scene.input.activePointer.y - touchStartPoint.y;
        if (Math.abs(dx) > 10 || Math.abs(dy) > 10) {
            let angle = Math.atan2(dy, dx);
            vx = Math.cos(angle); vy = Math.sin(angle);
        }
    }
    if (vx !== 0 || vy !== 0) {
        const vec = new Phaser.Math.Vector2(vx, vy).normalize().scale(CONFIG.SPEED_PLAYER);
        player.setVelocity(vec.x, vec.y);
    }
}

function setupVirtualJoystick(scene) {
    scene.input.on('pointerdown', (pointer) => { touchStartPoint.x = pointer.x; touchStartPoint.y = pointer.y; isTouching = true; });
    scene.input.on('pointerup', () => { isTouching = false; });
}

function hitEnemy(bullet, enemy) {
    if (!bullet.active || !enemy.active) return;
    bullet.setActive(false).setVisible(false).body.enable = false;
    applyDamageToEnemy(enemy, damagePerShot);
}

function hitEnemyByBoomerang(boomerang, enemy) {
    if (!enemy.active) return;
    const now = game.loop.now;
    if (now - enemy.lastBoomerangHit > 500) {
        enemy.lastBoomerangHit = now;
        applyDamageToEnemy(enemy, CONFIG.DAMAGE_BOOMERANG); 
    }
}

function applyDamageToEnemy(enemy, dmg) {
    if (enemy.isDying) return; 
    enemy.hp -= dmg;
    
    try { SFX.enemy_hit(); } catch (e) {}
enemy.setTintFill(0xffffff);
    enemy.scene.time.delayedCall(50, () => { if(enemy.active) enemy.clearTint(); });
    enemy.stunUntil = enemy.scene.time.now + CONFIG.HIT_STUN_DURATION;
    if (enemy.hp <= 0) killEnemy(enemy);
}

function flashHit(sprite, scene) {
    if (!sprite || !sprite.active) return;
    if (sprite.__tintTimer) { try { sprite.__tintTimer.remove(false); } catch (e) {} sprite.__tintTimer = null; }
    try { sprite.setTintFill(0xffffff); } catch (e) {}
    sprite.__tintTimer = scene.time.delayedCall(100, () => {
        if (!sprite || !sprite.active) return;
        try { sprite.clearTint(); } catch (e) {}
        sprite.__tintTimer = null;
    });
}

function flashShipAndWheels(scene) {
    flashHit(player, scene);
    flashHit(wheelLeft, scene);
    flashHit(wheelRight, scene);
}

function handleTrample(obj, enemy) {
    if (gameOver || !enemy.active || enemy.isDying) return;
    if (!isDebugMode) {
                // damage reduced by POWERUP pickups: every 2 POWERUPs reduces damage by 1, min damage is 2
        let trampleDmg = CONFIG.HP_TRAMPLE_COST;
        try {
            const reduction = Math.min(CONFIG.HP_TRAMPLE_COST - 2, Math.floor((powerupsCollected || 0) / 2));
            trampleDmg = Math.max(2, CONFIG.HP_TRAMPLE_COST - reduction);
        } catch (e) {}
        hp -= trampleDmg;
        // track consecutive damage to boost HEART drops
        try {
            const nowMs = this.time.now;
            if (nowMs - recentDamageLastAt <= 900) recentDamageStreak = Math.min(recentDamageStreak + 1, 6);
            else recentDamageStreak = 1;
            recentDamageLastAt = nowMs;
            recentDamageWindowUntil = nowMs + 1500;
        } catch (e) {}
        try { SFX.player_hit(); } catch (e) {}
showDamageFloatText(this, player.x, player.y - 60, `-${trampleDmg}`, '#ff0000');
        flashShipAndWheels(this);
    }
    this.cameras.main.shake(100, 0.005);
    killEnemy(enemy);
    if (!isDebugMode && hp <= 0) { if (!shipDestroyedSequence) { try { if (window.SFX && window.SFX.survival_fail) window.SFX.survival_fail(); } catch(e) {} } startShipDestroyedSequence(this); }
}

function killEnemy(enemy) {
    if (!enemy.active || enemy.isDying) return; 
    enemy.isDying = true; enemy.body.enable = false; enemy.setVelocity(0); 
    if (enemy.shadow) enemy.shadow.destroy();
    explosionEmitter.emitParticleAt(enemy.x, enemy.y, 6);
    
    try { SFX.enemy_die(); } catch (e) {}
comboCount++;
    if (comboTimerEvent) comboTimerEvent.remove(); 
    comboTimerEvent = enemy.scene.time.delayedCall(CONFIG.COMBO_TIMEOUT, resetCombo, [], enemy.scene);
    updateComboUI(); 
    let killScore = 10 + (comboCount * 2);

    // 【修复】如果正在播放死亡动画(shipDestroyedSequence)或游戏结束(gameOver)，不再加分
    if (!shipDestroyedSequence && !gameOver) {
        score += killScore;
    }

    enemy.setTexture('zombie_death');
    if (enemy.anims.currentAnim && enemy.anims.currentAnim.key === 'z_left') { enemy.setFlipX(true); } else { enemy.setFlipX(false); }
    const animKey = Math.random() < 0.5 ? 'death_1' : 'death_2';
    enemy.play(animKey);

    const chance = Phaser.Math.Between(0, 100);
    const elapsed = 60 - gameTime; 
    const allowedLetters = Math.floor(elapsed / 4) + 1;
    const allowedHearts = Math.floor(elapsed / 6) + 1;
    let allowedPowerUps = 0;
    if (elapsed < 30) allowedPowerUps = Math.floor(elapsed / 6) + 1;
    else if (elapsed < 50) allowedPowerUps = 5;
    else allowedPowerUps = 8;
    let allowedTurretsTotal = 1; 
    if (elapsed < 15) allowedTurretsTotal = 3;      
    else if (elapsed < 30) allowedTurretsTotal = 5; 
    else allowedTurretsTotal = 6;                   
    // HEART drop rules:
// 1) no HEART if HP is full
// 2) only after 10s elapsed
// 3) higher chance during consecutive damage windows
const heartEligible = (elapsed >= 10 && hp < maxHp);
let heartChance = 8;
try {
    const nowMs = enemy.scene.time.now;
    if (nowMs <= recentDamageWindowUntil) {
        heartChance = Math.min(8 + (Math.max(0, recentDamageStreak) * 3), 35);
    }
} catch (e) {}
if (heartEligible && chance < heartChance) {
        if (droppedCounts.heart < CONFIG.LIMIT_HEART && droppedCounts.heart < allowedHearts) dropItem(enemy.scene, enemy.x, enemy.y, 'HEART');
    } else if (chance < 25) {
        let turretsOnGround = pickups.getChildren().filter(p => p.active && p.dropType === 'TURRET').length;
        let currentTotal = activeTurrets.length + turretsOnGround;
        if (currentTotal < allowedTurretsTotal) dropItem(enemy.scene, enemy.x, enemy.y, 'TURRET');
        else if (collectedIndices.length < allowedLetters) dropItem(enemy.scene, enemy.x, enemy.y, 'LETTER');
    } else if (chance < 40) {
        if (droppedCounts.powerup < CONFIG.LIMIT_POWERUP && droppedCounts.powerup < allowedPowerUps) dropItem(enemy.scene, enemy.x, enemy.y, 'POWERUP');
    } else {
        if (collectedIndices.length < allowedLetters) dropItem(enemy.scene, enemy.x, enemy.y, 'LETTER');
    }
    enemy.once('animationcomplete', () => {
        enemy.scene.tweens.add({ targets: enemy, alpha: 0, duration: 120, yoyo: true, repeat: 1, delay: 200, onComplete: () => { enemy.destroy(); } });
    });
}


function clearAllEnemiesForWin(scene) {
    try {
        if (!enemies) return;
        const list = enemies.getChildren();
        for (let i = 0; i < list.length; i++) {
            const e = list[i];
            if (!e) continue;
            // Remove without affecting score/combo/drops
            try { e.isDying = true; } catch (err) {}
            try { if (e.body) e.body.enable = false; } catch (err) {}
            try { e.setVelocity(0); } catch (err) {}
            try { if (e.shadow) { e.shadow.destroy(); e.shadow = null; } } catch (err) {}
            try { if (explosionEmitter) explosionEmitter.emitParticleAt(e.x, e.y, 4); } catch (err) {}
            try { e.destroy(); } catch (err) {}
        }
        try { enemies.clear(true, true); } catch (err) {}
    } catch (e) {}
}

function resetCombo() { if(comboCount > 0) { comboText.setText(""); comboCount = 0; } }

function updateComboUI() {
    if (comboCount > 1) {
        comboText.setText(`COMBO x${comboCount}`); comboText.setVisible(true); comboText.setScale(1.5);
        if(comboScaleTween) comboScaleTween.stop();
        comboScaleTween = game.scene.scenes[0].tweens.add({ targets: comboText, scaleX: 1, scaleY: 1, duration: 200, ease: 'Back.out' });
    } else { comboText.setVisible(false); }
}

function dropItem(scene, x, y, type) {
    setActionLog("Dropped " + type);
    if (type === 'LETTER') {
        let needed = [];
        targetLetters.forEach((l, i) => { if(!collectedIndices.includes(i)) needed.push({l, i}); });
        if (needed.length === 0) type = 'HEART'; 
    }
    if (type === 'POWERUP') droppedCounts.powerup++;
    if (type === 'HEART') droppedCounts.heart++;
    
    let sprite;
    if (type === 'TURRET') {
        const rand = Math.random();
        let specificType = 'GUN';
        if (rand < 0.33) specificType = 'GUN';
        else if (rand < 0.66) specificType = 'BOOMERANG';
        else specificType = 'CANNON';
        let tex;
        if (specificType === 'GUN') tex = 'gun8dir';
        else if (specificType === 'CANNON') tex = 'cannon8dir';
        else tex = 'boomerang8dir';
        sprite = pickups.create(x, y, tex);
        sprite.play('spin_' + specificType.toLowerCase()); 
        sprite.setScale(0.6); sprite.specificType = specificType; 
        sprite.setDrag(1000); sprite.setBounce(0.5); sprite.setCircle(40); 
    } else {
        if (type === 'HEART') {
            sprite = pickups.create(x, y, 'heartSheet', 0);
            sprite.play('spin_heart');
            sprite.setScale(0.7); sprite.setCircle(40);
            if (sprite.body) { sprite.body.setAllowGravity(false); sprite.body.setImmovable(true); sprite.body.setSize(90, 90, true); }
            try { scene.physics.add.collider(enemies, sprite); } catch (e) {}
        }
        else if (type === 'POWERUP') {
            sprite = pickups.create(x, y, 'powerupSheet', 0);
            sprite.play('spin_powerup');
            sprite.setScale(0.8); sprite.setCircle(40);
            if (sprite.body) { sprite.body.setAllowGravity(false); sprite.body.setImmovable(true); sprite.body.setSize(90, 90, true); }
            try { scene.physics.add.collider(enemies, sprite); } catch (e) {}
        }
        else if (type === 'LETTER') {
            let needed = [];
            targetLetters.forEach((l, i) => { if (!collectedIndices.includes(i) && !droppedLetterIndices.includes(i)) needed.push({ l, i }); });
            if (needed.length === 0) return; 
            let pick = Phaser.Utils.Array.GetRandom(needed);
            const letterSpr = scene.add.sprite(x, y, 'hnyLetters', pick.i).setOrigin(0.5);
            letterSpr.setScale(0.42);
            scene.physics.add.existing(letterSpr);
            if (letterSpr.body) { letterSpr.body.setAllowGravity(false); letterSpr.body.setImmovable(true); letterSpr.body.setSize(90, 90, true); }
            letterSpr.canMagnet = false;
            pickups.add(letterSpr);
            letterSpr.pickupReady = false;
            scene.time.delayedCall(2000, () => { if (letterSpr.active) autoCollectLetterToHUD(scene, letterSpr); });
            scene.tweens.add({ targets: letterSpr, y: y - 8, duration: 650, yoyo: true, repeat: -1, ease: 'Sine.easeInOut' });
            try { scene.physics.add.collider(enemies, letterSpr); } catch (e) {}
            sprite = letterSpr; sprite.letterIndex = pick.i;
            if (!droppedLetterIndices.includes(pick.i)) droppedLetterIndices.push(pick.i);
        }
        scene.tweens.add({ targets: sprite, y: y - 10, duration: 500, yoyo: true, repeat: -1 });
    }
    if (type === 'TURRET' || type === 'POWERUP' || type === 'HEART') {
        sprite.shadow = scene.add.sprite(x, y, 'shadowTex');
        sprite.shadow.setDepth(1); sprite.shadow.setScale(1.9); sprite.shadow.alpha = 0.4;
    }
    sprite.dropType = type;
    sprite.isMagneting = false; sprite.canMagnet = false;
    scene.time.delayedCall(1000, () => { if(sprite.active) sprite.canMagnet = true; });
    sprite.setDepth(6);
}


function applyLetterBonuses() {
    const s = new Set(collectedIndices || []);
    if (!letterBonusFlags.happy && [0,1,2,3,4].every(i => s.has(i))) { score += 500; letterBonusFlags.happy = true; }
    if (!letterBonusFlags.new   && [5,6,7].every(i => s.has(i)))     { score += 300; letterBonusFlags.new = true; }
    if (!letterBonusFlags.year  && [8,9,10,11].every(i => s.has(i))) { score += 400; letterBonusFlags.year = true; }
    if (!letterBonusFlags.all && letterBonusFlags.happy && letterBonusFlags.new && letterBonusFlags.year) { score += 1000; letterBonusFlags.all = true; }
}

function autoCollectLetterToHUD(scene, drop) {
    try { SFX.letter_collect(); } catch (e) {}
    if (!drop || !drop.active) return;
    if (typeof drop.letterIndex !== 'number') return;
    if (!hnyHudSprites || !hnyHudSprites.list || !hnyHudSprites.list[drop.letterIndex]) {
        if (!collectedIndices.includes(drop.letterIndex)) { collectedIndices.push(drop.letterIndex); score += 100; applyLetterBonuses(); updateLetterUI(); }
        try { drop.destroy(); } catch (e) {}
        return;
    }
    if (collectedIndices.includes(drop.letterIndex)) { try { drop.destroy(); } catch (e) {} return; }
    const cam = scene.cameras.main;
    const hudSpr = hnyHudSprites.list[drop.letterIndex];
    const tx = hnyHudSprites.x + hudSpr.x;
    const ty = hnyHudSprites.y + hudSpr.y;
    const sx = drop.x - cam.scrollX;
    const sy = drop.y - cam.scrollY;
    const fly = scene.add.sprite(sx, sy, 'hnyLetters', drop.letterIndex).setOrigin(0.5).setScale(drop.scaleX || 0.42).setScrollFactor(0).setDepth(2000);
    try { drop.destroy(); } catch (e) {}
    scene.tweens.add({
        targets: fly, x: tx, y: ty, scaleX: hudSpr.scaleX || 0.42, scaleY: hudSpr.scaleY || 0.42, duration: 260, ease: 'Quad.easeInOut',
        onComplete: () => {
            try { fly.destroy(); } catch (e) {}
            collectedIndices.push(drop.letterIndex); updateLetterUI();
            try {
                const spr = hnyHudSprites.list[drop.letterIndex];
                const baseScale = spr.scaleX || 0.42;
                scene.tweens.add({ targets: spr, scaleX: baseScale * 1.18, scaleY: baseScale * 1.18, duration: 90, yoyo: true, ease: 'Quad.easeOut' });
                spr.setBlendMode(Phaser.BlendModes.ADD); spr.setTintFill(0xffffaa);
                scene.time.delayedCall(120, () => { if (!spr || !spr.active) return; spr.clearTint(); spr.setBlendMode(Phaser.BlendModes.NORMAL); });
            } catch (e) {}
        }
    });
}

function showHPSprite(scene) {
    if (!player || !player.active) return;
    try { if (window._activeHPText && window._activeHPText.active) { window._activeHPText.destroy(); } } catch (e) {}
    const img = scene.add.image(player.x, player.y - 80, 'textHP').setDepth(1000).setScale(0.5);
    window._activeHPText = img;
    const floatObj = { v: 0 };
    const follow = () => { if (!img.active || !player || !player.active) { scene.events.off('update', follow); return; } img.x = player.x; img.y = player.y - 80 + floatObj.v; };
    scene.events.on('update', follow);
    scene.tweens.add({ targets: floatObj, v: -40, duration: 1000, ease: 'Cubic.easeOut' });
    scene.tweens.add({ targets: img, alpha: 0, duration: 250, delay: 1000, ease: 'Linear', onComplete: () => { try { scene.events.off('update', follow); } catch (e) {} try { if (window._activeHPText === img) window._activeHPText = null; } catch (e) {} img.destroy(); } });
}

function showPowerupSprite(scene) {
    if (!player || !player.active) return;
    try { if (window._activePowerupText && window._activePowerupText.active) { window._activePowerupText.destroy(); } } catch (e) {}
    const img = scene.add.image(player.x, player.y - 80, 'textPowerup').setDepth(1000).setScale(0.5);
    window._activePowerupText = img;
    const floatObj = { v: 0 };
    const follow = () => { if (!img.active || !player || !player.active) { scene.events.off('update', follow); return; } img.x = player.x; img.y = player.y - 80 + floatObj.v; };
    scene.events.on('update', follow);
    scene.tweens.add({ targets: floatObj, v: -40, duration: 1000, ease: 'Cubic.easeOut' });
    scene.tweens.add({ targets: img, alpha: 0, duration: 250, delay: 1000, ease: 'Linear', onComplete: () => { try { scene.events.off('update', follow); } catch (e) {} try { if (window._activePowerupText === img) window._activePowerupText = null; } catch (e) {} img.destroy(); } });
}

function flashPowerupGreen(scene) {
    try {
        const targets = [];
        if (player && player.active) targets.push(player);
        if (wheelLeft && wheelLeft.active) targets.push(wheelLeft);
        if (wheelRight && wheelRight.active) targets.push(wheelRight);
        if (Array.isArray(activeTurrets)) { activeTurrets.forEach(t => { if (t && t.active) targets.push(t); }); }
        if (Array.isArray(turretSlots)) { turretSlots.forEach(s => { if (s && s.turret && s.turret.active) targets.push(s.turret); }); }
        if (targets.length === 0) return;
        targets.forEach(s => { s.setTintFill(0x000fff0); });
        scene.time.delayedCall(60, () => { targets.forEach(s => { if (s && s.active) s.clearTint(); }); });
    } catch (e) {}
}

function collectPickup(player, drop) {
    const scene = drop.scene;
    if (drop.dropType === 'LETTER') return;
    setActionLog("Get " + drop.dropType);
    if (drop.dropType === 'HEART') {
        hp = Math.min(hp + 20, maxHp); try { SFX.hp_pickup(); } catch (e) {} showHPSprite(scene); flashPowerupGreen(scene);
    } else if (drop.dropType === 'TURRET') {
        if (activeTurrets.length < 6) {
            addTurret(scene, drop.specificType); 
             try { SFX.ui_click(); } catch (e) {}
            let msg = drop.specificType; if(msg === 'BOOMERANG') msg = 'SAW!';
            showFloatText(scene, player.x, player.y, msg + "!", COLORS.TURRET);
        } else { score += 200; showFloatText(scene, player.x, player.y, "+200", COLORS.TURRET); }
    } else if (drop.dropType === 'POWERUP') {
        try { powerupsCollected++; } catch (e) {}
        damagePerShot += 1; try { SFX.powerup_pickup(); } catch (e) {} showPowerupSprite(scene); score += 100; flashPowerupGreen(scene);
    }
    else if (drop.dropType === 'LETTER') {
        if (!collectedIndices.includes(drop.letterIndex)) {
            try {
                if (hnyHudSprites && hnyHudSprites.list && hnyHudSprites.list[drop.letterIndex]) {
                    const hudSpr = hnyHudSprites.list[drop.letterIndex];
                    const fly = scene.add.sprite(drop.x, drop.y, 'hnyLetters', drop.letterIndex).setOrigin(0.5).setScale(drop.scaleX || 0.42).setDepth(2000);
                    const tx = hnyHudSprites.x + hudSpr.x;
                    const ty = hnyHudSprites.y + hudSpr.y;
                    scene.tweens.add({
                        targets: fly, x: tx, y: ty, scaleX: hudSpr.scaleX || 0.42, scaleY: hudSpr.scaleY || 0.42, duration: 260, ease: 'Quad.easeInOut',
                        onComplete: () => {
                            try { fly.destroy(); } catch (e) {}
                            collectedIndices.push(drop.letterIndex); updateLetterUI();
                            try {
                                const spr = hnyHudSprites.list[drop.letterIndex];
                                const baseScale = spr.scaleX || 0.42;
                                scene.tweens.add({ targets: spr, scaleX: baseScale * 1.18, scaleY: baseScale * 1.18, duration: 90, yoyo: true, ease: 'Quad.easeOut' });
                                spr.setBlendMode(Phaser.BlendModes.ADD); spr.setTintFill(0xffffaa);
                                scene.time.delayedCall(120, () => { if (!spr || !spr.active) return; spr.clearTint(); spr.setBlendMode(Phaser.BlendModes.NORMAL); });
                            } catch (e) {}
                        }
                    });
                } else { collectedIndices.push(drop.letterIndex); updateLetterUI(); }
            } catch (e) { collectedIndices.push(drop.letterIndex); updateLetterUI(); }
            showFloatText(scene, player.x, player.y, drop.text, COLORS.LETTER);
            score += 500;
        }
    }
    if (drop.shadow) drop.shadow.destroy();
    drop.destroy();
}

function showFloatText(scene, x, y, msg, color) {
    const txt = scene.add.text(x, y - 40, msg, { fontSize: '18px', color: (typeof color === 'string' ? color : '#' + color.toString(16)), fontStyle: 'bold', stroke: '#fff', strokeThickness: 3 }).setOrigin(0.5).setDepth(100);
    scene.tweens.add({ targets: txt, y: y - 100, alpha: 0, duration: 800, onComplete: () => txt.destroy() });
}


function showDamageFloatText(scene, x, y, msg, color) {
    // Bigger, higher, and with random X offset for ship-damage HP loss indicator only
    const ox = (Phaser && Phaser.Math && Phaser.Math.Between) ? Phaser.Math.Between(-50, 50) : (Math.random() * 60 - 30);
    const txt = scene.add.text(x + ox, y - 90, msg, { 
        fontSize: '27px',
        fontFamily: '"Press Start 2P"',
        fill: color || '#ff0000',
        stroke: '#fff',
        strokeThickness: 4
    }).setOrigin(0.5).setDepth(100);
    scene.tweens.add({ targets: txt, y: y - 150, alpha: 0, duration: 800, onComplete: () => txt.destroy() });
}

function generateTextures(scene) {
    const g = scene.make.graphics({x:0, y:0, add:false});
    g.clear(); g.fillStyle(0x000000, 1); g.fillCircle(16, 16, 14); g.generateTexture('shadowTex', 32, 32);
    g.clear(); g.fillStyle(0xFFFFFF, 1); g.fillRect(0, 0, 16, 16); g.generateTexture('trailSquare', 16, 16);
    g.clear(); g.fillStyle(COLORS.TURRET, 1); g.fillTriangle(24, 12, 0, 0, 0, 24); g.lineStyle(1, 0x000000); g.strokeTriangle(24, 12, 0, 0, 0, 24); g.generateTexture('turretTex', 24, 24);
    g.clear(); g.fillStyle(COLORS.BOOMERANG_RING, 1); g.fillCircle(12, 12, 10); g.lineStyle(2, 0x000000); g.strokeCircle(12, 12, 10); g.generateTexture('boomerangIconTex', 24, 24);
    g.clear(); g.lineStyle(4, COLORS.BOOMERANG_RING); g.strokeCircle(20, 20, 16); g.generateTexture('boomerangProjTex', 40, 40);
    g.clear(); g.fillStyle(COLORS.CANNON_ICON, 1); g.fillRect(0,0,24,24); g.lineStyle(2, 0x000000); g.strokeRect(0,0,24,24); g.generateTexture('cannonIconTex', 24, 24);
    g.clear(); g.fillStyle(COLORS.CANNON_BALL, 1); g.fillCircle(8,8,8); g.generateTexture('cannonBallTex', 16, 16);
    g.clear(); g.fillStyle(COLORS.TRAIL_SMOKE, 1); g.fillCircle(5,5,5); g.generateTexture('trailTex', 10, 10);
    g.clear(); g.fillStyle(COLORS.TURRET, 1); g.lineStyle(2,0); g.fillRect(0,0,20,20); g.strokeRect(0,0,20,20); g.generateTexture('turretDropTex', 20, 20);
    //g.clear(); g.fillStyle(COLORS.ARROW, 1); g.fillTriangle(40, 20, 0, 40, 0, 0); g.generateTexture('arrowTex', 40, 40);
    g.clear(); g.fillStyle(COLORS.BULLET, 1); g.fillCircle(4,4,4); g.generateTexture('bulletTex', 8, 8);
    // Heart texture for HP icon
    g.clear(); g.fillStyle(COLORS.HEART, 1); g.fillCircle(8,8,8); g.generateTexture('heartTex', 16, 16);
    g.clear(); g.fillStyle(COLORS.POWERUP_BG, 1); g.fillRect(0,0,24,24); g.lineStyle(2, 0xffffff); g.strokeRect(0,0,24,24); g.fillStyle(0xffffff, 1); g.fillRect(4, 4, 16, 4); g.fillRect(4, 4, 4, 16); g.fillRect(16, 4, 4, 8); g.fillRect(4, 12, 16, 4); g.generateTexture('powerupTex', 24, 24);
    g.clear(); g.fillStyle(COLORS.HAPPY, 1); g.fillCircle(12, 12, 12); g.fillStyle(0x000000, 1); g.fillCircle(8, 10, 2); g.fillCircle(16, 10, 2); g.beginPath(); g.lineStyle(2, 0x000000); g.arc(12, 12, 6, 0.1*Math.PI, 0.9*Math.PI, false); g.strokePath(); g.generateTexture('happyTex', 24, 24);
    
    // MODIFIED: Generate Clock Texture
    g.clear();
    g.fillStyle(0x555555, 1); // rim
    g.fillCircle(16, 16, 16);
    g.fillStyle(0xFFFFFF, 1); // face
    g.fillCircle(16, 16, 13);
    g.fillStyle(0xCC0000, 1); // hands
    g.fillRect(15, 6, 2, 10); // vertical hand
    g.fillRect(15, 15, 8, 2); // horizontal hand
    g.generateTexture('clockTex', 32, 32);

    const zG = scene.make.graphics({x:0, y:0, add:false});
    const size = 128;
    for(let row=0; row<4; row++) {
        for(let col=0; col<4; col++) {
            const cx = col * size + size/2;
            const cy = row * size + size/2;
            zG.fillStyle(0x448844, 1);
            zG.fillRect(col*size + 10, row*size + 10, size-20, size-20);
            zG.fillStyle(0xFFFFFF, 1);
            if(col === 0) { zG.fillTriangle(cx-10, cy-10, cx+10, cy-10, cx, cy+20); } 
            else if(col === 1) { zG.fillTriangle(cx-10, cy+10, cx+10, cy+10, cx, cy-20); } 
            else if(col === 2) { zG.fillTriangle(cx+10, cy-10, cx+10, cy+10, cx-20, cy); } 
            else { zG.fillTriangle(cx-10, cy-10, cx-10, cy+10, cx+20, cy); }
        }
    }
    zG.generateTexture('zombie_sheet', 512, 512);
}

function createUI(scene) {
    // MODIFIED: UI Layout Update (Pixel Font, Icons)

    // 1. Background Boxes (New)
    hudBg = scene.add.graphics();
    hudBg.setScrollFactor(0);
    hudBg.setDepth(160); // 层级，在文字下面(文字是200)
    
    // 设置颜色和透明度
    // 0x000000 是黑色
    // 0.5 是透明度 (0.0 完全透明 ~ 1.0 不透明)
    hudBg.fillStyle(0x000000, 0.5); 
    
    // === HP 的背景框 (左上角) ===
    // 参数顺序: (x坐标, y坐标, 宽度, 高度, 圆角半径)
    // 目前尺寸: 宽130, 高50
    hudBg.fillRoundedRect(-50, -115, 130, 45, 8);

    // === Score 的背景框 (右上角) ===
    // x坐标计算: 屏幕总宽(540) - 260 = 280
    // 目前尺寸: 宽250, 高50
    hudBg.fillRoundedRect(gameConfig.scale.width - 230, -115, 290, 45, 8);


    // 1. HP Icon + Text (Top Left)
    const uiY_Row1 = -90;
    
    hpIcon = scene.add.sprite(-30, uiY_Row1, 'heartSheet', 3).setScrollFactor(0).setDepth(200).setScale(0.3);
    hpText = scene.add.text(-10, uiY_Row1, 'x100', { 
        fontSize: '20px', 
        fontFamily: '"Press Start 2P"',
        fill: '#FFFFFF' 
    }).setOrigin(0, 0.5).setScrollFactor(0).setDepth(200);

    // 2. Score (Top Right)
    scoreText = scene.add.text(gameConfig.scale.width +50, uiY_Row1, 'SCORE: 0', { 
        fontSize: '20px', 
        fontFamily: '"Press Start 2P"', 
        fill: '#FFFFFF' 
    }).setOrigin(1, 0.5).setScrollFactor(0).setDepth(200);

    // 3. Clock + Time (Bottom Center - Row 2)
    const uiY_Row2 = -20;
    const centerX = gameConfig.scale.width / 2;
    
    // Icon (Left of text)
    // Text (Right of icon)
    // Countdown digits (spritesheet 0-9)
    const digitScale = 0.6;
    const digitW = 110 * digitScale;
    const digitGap = -10;
    // Keep the original timeText (hidden) for compatibility, but we no longer use it for rendering
    timeText = scene.add.text(centerX - 10, uiY_Row2 + 5, '', { 
        fontSize: '1px', 
        fontFamily: '"Press Start 2P"', 
        fill: '#000000'
    }).setOrigin(0, 0.5).setScrollFactor(0).setDepth(200).setVisible(false);

    timeDigitTens = scene.add.sprite(centerX - 70, uiY_Row2 + 10, 'countdownNumbers', 6)
        .setOrigin(0, 0.5).setScrollFactor(0).setDepth(200).setScale(digitScale);

    timeDigitOnes = scene.add.sprite(centerX - 70 + digitW + digitGap, uiY_Row2 + 10, 'countdownNumbers', 0)
        .setOrigin(0, 0.5).setScrollFactor(0).setDepth(200).setScale(digitScale);
// Bottom Letter HUD
    letterText = null;
    hnyHudSprites = scene.add.container(scene.scale.width / 2, scene.scale.height - 120).setScrollFactor(0).setDepth(999);
    
    // === UI Intro Animation Setup (HUD hidden until game starts) ===
    uiIntroTargets = {
        hudBgY: hudBg ? hudBg.y : 0,
        hpIconY: hpIcon ? hpIcon.y : 0,
        hpTextY: hpText ? hpText.y : 0,
        scoreTextY: scoreText ? scoreText.y : 0,
        timeTextY: timeText ? timeText.y : 0,
        timeDigitTensY: timeDigitTens ? timeDigitTens.y : 0,
        timeDigitOnesY: timeDigitOnes ? timeDigitOnes.y : 0,
        hnyHudY: hnyHudSprites ? hnyHudSprites.y : 0
    };

    const TOP_OFF = -220; // fly-in from above
    const BOTTOM_OFF = 260; // fly-in from below

    // Hide top HUD (HP / SCORE / TIMER) until game starts
    if (hudBg) { hudBg.y = uiIntroTargets.hudBgY + TOP_OFF; hudBg.setVisible(false); }
    if (hpIcon) { hpIcon.y = uiIntroTargets.hpIconY + TOP_OFF; hpIcon.setVisible(false); }
    if (hpText) { hpText.y = uiIntroTargets.hpTextY + TOP_OFF; hpText.setVisible(false); }
    if (scoreText) { scoreText.y = uiIntroTargets.scoreTextY + TOP_OFF; scoreText.setVisible(false); }
    if (timeText) { timeText.y = uiIntroTargets.timeTextY + TOP_OFF; timeText.setVisible(false); }
    if (timeDigitTens) { timeDigitTens.y = uiIntroTargets.timeDigitTensY + TOP_OFF; timeDigitTens.setVisible(false); }
    if (timeDigitOnes) { timeDigitOnes.y = uiIntroTargets.timeDigitOnesY + TOP_OFF; timeDigitOnes.setVisible(false); }

    // Hide bottom HNY HUD until game starts
    if (hnyHudSprites) { hnyHudSprites.y = uiIntroTargets.hnyHudY + BOTTOM_OFF; hnyHudSprites.setVisible(false); }
const hudScale = 0.42; 
    const total = targetLetters.length;
    const spacing = (110 * hudScale + 5) * 0.85;     
    const wordGap = spacing * 0.75;         
    const totalWidth = ((total - 1) * spacing) + (2 * wordGap);
    const startX = -(totalWidth) / 2;
    for (let i = 0; i < total; i++) {
        const extraGap = (i > 4 ? wordGap : 0) + (i > 7 ? wordGap : 0);
        const s = scene.add.sprite(startX + i * spacing + extraGap, 0, 'hnyLetters', i).setDepth(999);
        s.setScale(hudScale);
        s.setOrigin(0.5);        
        if (!collectedIndices.includes(i)) s.setTexture('questionMark');
        hnyHudSprites.add(s);
    }
    
    fpsText = scene.add.text(10, gameConfig.scale.height - 30, 'FPS: 60', { fontSize: '14px', fill: '#00aa00', fontStyle: 'bold', stroke: '#fff', strokeThickness: 2 }).setScrollFactor(0).setDepth(500);
    fpsText.setVisible(false); // Hide FPS as requested

    comboText = scene.add.text(hpIcon.x -25, 150, '', { 
    fontSize: '24px', 
    fontFamily: '"Press Start 2P"',  // <--- 重点：加了双引号
    fill: '#FF4500', 
    fontStyle: 'bold', 
    stroke: '#fff', 
    strokeThickness: 6 
}).setScrollFactor(0).setDepth(200).setVisible(false);
    
    // REMOVED High Score Text from HUD
}


function runHUDIntro(scene) {
    if (!uiIntroTargets) return;

    const DUR = 220;
    const DELAY = 0; // delay handled by caller
    const EASE = 'Back.out';

    // Make visible before tween
    if (hudBg) hudBg.setVisible(true);
    if (hpIcon) hpIcon.setVisible(true);
    if (hpText) hpText.setVisible(true);
    if (scoreText) scoreText.setVisible(true);
    if (timeText) timeText.setVisible(true);
    if (timeDigitTens) timeDigitTens.setVisible(true);
    if (timeDigitOnes) timeDigitOnes.setVisible(true);
    if (hnyHudSprites) hnyHudSprites.setVisible(true);

    // Top HUD fly in from above
    if (hudBg) scene.tweens.add({ targets: hudBg, y: uiIntroTargets.hudBgY, duration: DUR, delay: DELAY, ease: EASE });
    if (hpIcon) scene.tweens.add({ targets: hpIcon, y: uiIntroTargets.hpIconY, duration: DUR, delay: DELAY, ease: EASE });
    if (hpText) scene.tweens.add({ targets: hpText, y: uiIntroTargets.hpTextY, duration: DUR, delay: DELAY, ease: EASE });
    if (scoreText) scene.tweens.add({ targets: scoreText, y: uiIntroTargets.scoreTextY, duration: DUR, delay: DELAY, ease: EASE });
    if (timeText) scene.tweens.add({ targets: timeText, y: uiIntroTargets.timeTextY, duration: DUR, delay: DELAY, ease: EASE });
    if (timeDigitTens) scene.tweens.add({ targets: timeDigitTens, y: uiIntroTargets.timeDigitTensY, duration: DUR, delay: DELAY, ease: EASE });
    if (timeDigitOnes) scene.tweens.add({ targets: timeDigitOnes, y: uiIntroTargets.timeDigitOnesY, duration: DUR, delay: DELAY, ease: EASE });

    // Bottom HNY fly in from below
    if (hnyHudSprites) scene.tweens.add({ targets: hnyHudSprites, y: uiIntroTargets.hnyHudY, duration: DUR, delay: DELAY, ease: EASE });
}


function updateTimer() {
    if (gameOver) return;
    gameTime--;
    // Update countdown digit sprites (always force-read from gameTime)
    const t = Math.max(0, Math.floor(gameTime));
    const tens = Math.floor(t / 10);
    const ones = t % 10;
    if (timeDigitTens) timeDigitTens.setFrame(Math.max(0, Math.min(9, tens)));
    if (timeDigitOnes) timeDigitOnes.setFrame(Math.max(0, Math.min(9, ones)));
    if (gameTime <= 0 && !winSequence && !gameOver) {
        winSequence = true;

        // stop ticking further
        try { if (timerEvent) { timerEvent.remove(); timerEvent = null; } } catch (e) {}

        // wipe all zombies immediately
        clearAllEnemiesForWin(this);

        // victory SFX now (single-shot)
        try { if (window.SFX && window.SFX.survive_success) window.SFX.survive_success(); } catch (e) {}

        // Happy New Year victory glow + pops (2s)
        startVictoryHNYFX(this);

        // delay 2s, then show results
        this.time.delayedCall(2000, () => { doGameOver(this, true); }, [], this);
    }
}


function startVictoryHNYFX(scene) {
    try {
        if (!scene || !hnyHudSprites || !hnyHudSprites.list) return;
        const letters = hnyHudSprites.list.filter(s => s && s.active);
        if (!letters.length) return;

        letters.forEach(s => {
            if (s.__victoryBaseScale == null) s.__victoryBaseScale = s.scaleX || 1;
            if (s.__victoryBaseY == null) s.__victoryBaseY = s.y || 0;
            if (s.__victoryBaseRot == null) s.__victoryBaseRot = s.rotation || 0;
            s.__victoryBusy = false;
        });

        let tick = 0;
        const ev = scene.time.addEvent({
            delay: 120,
            loop: true,
            callback: () => {
                tick++;

                // Random pops (2–3 letters)
                const popCount = 2 + Math.floor(Math.random() * 2);
                for (let i = 0; i < popCount; i++) {
                    const spr = letters[Math.floor(Math.random() * letters.length)];
                    if (!spr || !spr.active) continue;
                    if (spr.__victoryBusy) continue;
                    spr.__victoryBusy = true;

                    const baseS = spr.__victoryBaseScale || spr.scaleX || 1;
                    const baseY = spr.__victoryBaseY || spr.y || 0;
                    const baseR = spr.__victoryBaseRot || spr.rotation || 0;

                    try {
                        spr.setBlendMode(Phaser.BlendModes.ADD);
                        spr.setTintFill(0xffffee);
                    } catch (e) {}

                    scene.tweens.add({
                        targets: spr,
                        y: baseY - (8 + Math.random() * 6),
                        scaleX: baseS * 1.20,
                        scaleY: baseS * 1.20,
                        rotation: baseR + (Math.random() < 0.5 ? -0.10 : 0.10),
                        duration: 90,
                        yoyo: true,
                        ease: 'Quad.easeOut',
                        onComplete: () => {
                            if (!spr) return;
                            spr.y = baseY;
                            spr.rotation = baseR;
                            spr.scaleX = baseS;
                            spr.scaleY = baseS;
                            try { spr.clearTint(); spr.setBlendMode(Phaser.BlendModes.NORMAL); } catch (e) {}
                            spr.__victoryBusy = false;
                        }
                    });
                }

                // Occasional sweep glow (subtle “firework pop” feel)
                if (tick % 6 === 0) {
                    letters.forEach((spr, idx) => {
                        scene.time.delayedCall(idx * 25, () => {
                            if (!spr || !spr.active) return;
                            const baseS = spr.__victoryBaseScale || spr.scaleX || 1;
                            try { spr.setBlendMode(Phaser.BlendModes.ADD); spr.setTintFill(0xffffff); } catch (e) {}
                            scene.tweens.add({
                                targets: spr,
                                scaleX: baseS * 1.12,
                                scaleY: baseS * 1.12,
                                duration: 70,
                                yoyo: true,
                                ease: 'Quad.easeOut',
                                onComplete: () => {
                                    if (!spr) return;
                                    try { spr.clearTint(); spr.setBlendMode(Phaser.BlendModes.NORMAL); } catch (e) {}
                                }
                            });
                        });
                    });
                }
            }
        });

        // Cleanup aligned with the 2s win delay
        scene.time.delayedCall(2000, () => {
            try { ev.remove(); } catch (e) {}
            letters.forEach(spr => {
                if (!spr) return;
                const baseS = spr.__victoryBaseScale || spr.scaleX || 1;
                const baseY = spr.__victoryBaseY || spr.y || 0;
                const baseR = spr.__victoryBaseRot || spr.rotation || 0;
                spr.y = baseY;
                spr.rotation = baseR;
                try { spr.setScale(baseS); spr.clearTint(); spr.setBlendMode(Phaser.BlendModes.NORMAL); } catch (e) {}
                spr.__victoryBusy = false;
            });
        });
    } catch (e) {}
}

function getLetterString() {
    let display = "";
    for(let i=0; i<targetLetters.length; i++) {
        if (collectedIndices.includes(i)) display += targetLetters[i] + " "; else display += "_ ";
    }
    return display;
}

function updateLetterUI() {
    if (hnyHudSprites) {
        const kids = hnyHudSprites.list || [];
        for (let i = 0; i < kids.length; i++) {
            const spr = kids[i];
            if (!spr) continue;
            if (collectedIndices.includes(i)) {
                spr.setTexture('hnyLetters', i); spr.clearTint(); spr.setBlendMode(Phaser.BlendModes.NORMAL);
            } else {
                spr.setTexture('questionMark'); spr.clearTint(); spr.setBlendMode(Phaser.BlendModes.NORMAL);
            }
        }
    } else if (letterText) { letterText.setText(getLetterString()); }
}

function startShipDestroyedSequence(scene) {
    if (shipDestroyedSequence) return;
    shipDestroyedSequence = true;
    
    try { SFX.explosion(); } catch (e) {}
try { if (window._activePowerupText && window._activePowerupText.active) { window._activePowerupText.destroy(); } if (window._activeHPText && window._activeHPText.active) { window._activeHPText.destroy(); } window._activePowerupText = null; window._activeHPText = null; } catch (e) {}
    try { if (timerEvent) { timerEvent.remove(); } } catch (e) {}
    try { if (fireEvent) { fireEvent.remove(); } } catch (e) {}
    try { if (comboTimerEvent) { comboTimerEvent.remove(); } } catch (e) {}
    try { if (player && player.body) { player.setVelocity(0); player.body.enable = false; } } catch (e) {}
    const DURATION_MS = 2000;
    const INTERVAL_MS = 180;
    const startTime = scene.time.now;
    const spawnOne = () => {
        if (!scene || !scene.add) return;
        const baseX = player?.x ?? (CONFIG.WIDTH / 2);
        const baseY = player?.y ?? (CONFIG.HEIGHT / 2);
        const w = (player?.displayWidth || player?.width || 140);
        const h = (player?.displayHeight || player?.height || 140);
        const points = [ { x: 0.0,  y: 0.0 }, { x: 0.0,  y: -0.28 }, { x: 0.0,  y: 0.26 }, { x: -0.26, y: -0.02 }, { x: 0.26,  y: -0.02 }, { x: -0.34, y: -0.12 }, { x:  0.34, y: -0.12 }, { x: -0.40, y:  0.18 }, { x:  0.40, y:  0.18 }, { x:  0.00, y:  0.34 } ];
        const p = points[Phaser.Math.Between(0, points.length - 1)];
        const jitterX = Phaser.Math.Between(-Math.max(16, w * 0.08), Math.max(16, w * 0.08));
        const jitterY = Phaser.Math.Between(-Math.max(16, h * 0.08), Math.max(16, h * 0.08));
        const ox = p.x * w + jitterX;
        const oy = p.y * h + jitterY;
        const boom = scene.add.sprite(baseX + ox, baseY + oy, 'explosion8', 0);
        boom.setDepth(9999); boom.setScale(0.9 + Math.random() * 0.4); boom.play('explosion_play');
        boom.once('animationcomplete', () => { boom.destroy(); });
    };
    spawnOne();
    scene.time.delayedCall(90, spawnOne);
    const loop = scene.time.addEvent({
        delay: INTERVAL_MS, loop: true,
        callback: () => {
            const elapsed = scene.time.now - startTime;
            if (elapsed >= DURATION_MS) { loop.remove(); doGameOver(scene, false); return; }
            spawnOne(); if (Math.random() < 0.35) spawnOne();
        }
    });
}

function doGameOver(scene, win) {  try { if (!win && window.SFX && window.SFX.ship_explode) window.SFX.ship_explode(); } catch(e) {}
    gameOver = true;
    try { BGM.stop(); } catch (e) {}
    try { scene.physics.pause(); } catch (e) {}
    try { if (timerEvent) { timerEvent.remove(); } } catch (e) {}
    try { if (fireEvent) { fireEvent.remove(); } } catch (e) {}
    try { if (comboTimerEvent) { comboTimerEvent.remove(); } } catch (e) {}
    const overlay = document.getElementById('game-over-ui');
    const goScore = document.getElementById('go-score');
    const goBest = document.getElementById('go-best');    const goLetters = document.getElementById('go-letters');
    const goTitle = document.getElementById('go-title');
    
    if (win && !window.__surviveBonusGiven) { score += 1000; window.__surviveBonusGiven = true; }
goScore.innerText = score;
    if (score > highScore) { saveHighScore(score); }
    goBest.innerText = highScore;
    try { renderHappyNewYearSpritesDOM(new Set(collectedIndices || [])); } catch (e) {}
    let letterStr = "";
    for(let i=0; i<targetLetters.length; i++) { if (collectedIndices.includes(i)) letterStr += targetLetters[i] + " "; else letterStr += "_ "; }
    goLetters.innerText = '';
    if (win) { goTitle.innerText = "HAPPY NEW YEAR!"; goTitle.style.color = "#FFD700"; } else { goTitle.innerText = "GAME OVER"; goTitle.style.color = "#FF0000"; }
    overlay.style.display = 'flex';
    try {
        window.LeaderboardAPI?.open?.({ score, nameInputId: 'player-name-input' });
    } catch (e) {}
}
</script>

<!-- FIREBASE & LEADERBOARD (FINAL WASD & ENTER FIX & MY RANK UI) -->
<script src="https://www.gstatic.com/firebasejs/12.6.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/12.6.0/firebase-firestore-compat.js"></script>
<script>
  (function () {
    const firebaseConfig = {
      apiKey: "AIzaSyBIOQqxS5fCFMLhkxXM4gQkfiANpLrNUV4",
      authDomain: "minsurvivor-3c2d1.firebaseapp.com",
      projectId: "minsurvivor-3c2d1",
      storageBucket: "minsurvivor-3c2d1.firebasestorage.app",
      messagingSenderId: "193473399866",
      appId: "1:193473399866:web:58359521495f4ebcddb903"
    };

    function $(id){ return document.getElementById(id); }
    function logDebug(action, value) { const time = new Date().toLocaleTimeString(); console.log(`%c[${time}] ${action}:`, "color: #00ff00; font-weight: bold;", value); }

    function getStatusEl(){ return $("lb-status") || $("lb-placeholder-text"); }
    function getListEl(){ return $("lb-top10"); }

    function setStatus(msg) {
      const el = getStatusEl(); if (!el) return;
      if (el.id === "lb-placeholder-text") el.innerHTML = String(msg || "").replace(/\\n/g, "<br>"); else el.textContent = msg || "";
    }

    function sanitizeName(name) { 
        return String(name || "").trim().replace(/\s+/g, " ").replace(/[^\w \-\u4e00-\u9fff]/g, "").slice(0, 12); 
    }

    function isNameLocked() { try { return localStorage.getItem("zr_name_locked") === "1"; } catch (e) { return false; } }
    
    function lockName(name) { 
        try { if (name) { localStorage.setItem("zr_player_name", name); localStorage.setItem("lb_name", name); localStorage.setItem("zr_name_locked", "1"); } } catch (e) {} 
    }

    function applyNameLockUI(inputEl) {
      if (!inputEl) return;
      const locked = isNameLocked();
      if (locked) { inputEl.readOnly = true; inputEl.disabled = true; inputEl.classList.add('nickname-locked'); } 
      else { inputEl.readOnly = false; inputEl.disabled = false; inputEl.classList.remove('nickname-locked'); }
    }

    function prefillName(inputEl) {
      try { const saved = localStorage.getItem("zr_player_name") || localStorage.getItem("lb_name") || ""; if (saved && inputEl) { inputEl.value = saved; } } catch (e) {}
      applyNameLockUI(inputEl);
    }

    function renderTop10(rows) {
      const listEl = getListEl(); if (!listEl) return; listEl.innerHTML = "";
      if (!rows || rows.length === 0) { const d = document.createElement("div"); d.style.color = "#888"; d.style.fontStyle = "italic"; d.textContent = "No scores yet."; listEl.appendChild(d); return; }
      rows.forEach((r, i) => {
        const item = document.createElement("div"); item.className = "lb-item";
        const left = document.createElement("div"); left.className = "lb-left";
        const rank = document.createElement("div"); rank.className = "lb-rank"; rank.textContent = "#"+(i+1);
        const name = document.createElement("div"); name.className = "lb-name"; name.textContent = r.nickname || "???";
        left.appendChild(rank); left.appendChild(name);
        const score = document.createElement("div"); score.className = "lb-score"; score.textContent = String(r.score ?? 0);
        item.appendChild(left); item.appendChild(score); listEl.appendChild(item);
      });
    }

    try { firebase.initializeApp(firebaseConfig); } catch (e) {}
    const db = firebase.firestore();

    // MODIFIED: Remove secondary sort to show all high scores
    async function loadTop10() {
      const snap = await db.collection("scores").orderBy("score", "desc").limit(10).get();
      return snap.docs.map(d => d.data());
    }

    // New Function to refresh BOTH Top 10 AND My Rank
    async function refreshTop10AndMyRank(myName) {
      try { 
          setStatus("Loading..."); 
          const rows = await loadTop10(); 
          renderTop10(rows); 
          setStatus(""); 
          
          if (myName) {
              await refreshMyRank(myName, rows);
          }
      } catch (e) { console.warn(e); setStatus("Leaderboard error: " + (e.message || e)); }
    }

    async function refreshMyRank(name, topRows) {
        const container = $("lb-my-rank-container");
        if (!container) return;
        // Keep clear at start for logic simplicity as requested in revert
        container.innerHTML = ''; 

        try {
            const ref = db.collection("scores").doc(name);
            const snap = await ref.get();
            if (!snap.exists) return; 

            const myData = snap.data();
            const myBest = myData.score || 0;
            
            // Check if I am in Top 10 list first (Visual Consistency)
            let rankDisplay = "?";
            let foundIndex = -1;
            
            if (topRows && topRows.length > 0) {
                foundIndex = topRows.findIndex(r => r.nickname === name);
            }

            if (foundIndex !== -1) {
                rankDisplay = "#" + (foundIndex + 1);
            } else {
                // Fallback query if not in top 10
                try {
                    const snapshot = await db.collection('scores').where('score', '>', myBest).get();
                    rankDisplay = "#" + (snapshot.size + 1);
                } catch(e) { console.log("Rank calc error", e); }
            }

            const item = document.createElement("div"); 
            item.className = "lb-item my-rank-row"; 
            
            const left = document.createElement("div"); 
            left.className = "lb-left";
            
            const rank = document.createElement("div"); 
            rank.className = "lb-rank"; 
            rank.textContent = rankDisplay;
            
            const nDiv = document.createElement("div"); 
            nDiv.className = "lb-name"; 
            nDiv.textContent = name;
            
            left.appendChild(rank); 
            left.appendChild(nDiv);
            
            const score = document.createElement("div"); 
            score.className = "lb-score"; 
            score.textContent = String(myBest);
            
            item.appendChild(left); 
            item.appendChild(score); 
            
            // Double clear just to be safe against race conditions (kept from your fix)
            container.innerHTML = '';
            container.appendChild(item);

        } catch(e) {}
    }

    async function submitScore(nickname, score) {
      const name = sanitizeName(nickname);
      const sc = Math.max(0, Math.floor(Number(score) || 0));
      if (!name) throw new Error("Please enter a nickname.");
      logDebug("API Submitting", { name: name, score: sc });
      const ref = db.collection("scores").doc(name);
      return await db.runTransaction(async (tx) => {
        const snap = await tx.get(ref);
        if (!snap.exists) { tx.set(ref, { nickname: name, score: sc, createdAt: firebase.firestore.FieldValue.serverTimestamp(), updatedAt: firebase.firestore.FieldValue.serverTimestamp() }); return { written: true, reason: "first", prevScore: 0 }; }
        const prev = snap.data() || {}; const prevScore = Number(prev.score || 0);
        if (sc > prevScore) { tx.set(ref, { nickname: name, score: sc, createdAt: prev.createdAt || firebase.firestore.FieldValue.serverTimestamp(), updatedAt: firebase.firestore.FieldValue.serverTimestamp() }, { merge: true }); return { written: true, reason: "improved", prevScore }; }
        return { written: false, reason: "not_higher", prevScore };
      });
    }

    let __autoSubmitPromise = null; let __submittedForThisOpen = false;
    function getFreshInputValue() { const el = $("player-name-input"); if (!el) return ""; return el.value; }

    function updateNameUI() {
      const inputEl = $("player-name-input"); 
      const currentVal = inputEl ? inputEl.value : "";
      let saved = ""; try { saved = (localStorage.getItem("zr_player_name") || localStorage.getItem("lb_name") || "").trim(); } catch(e) {}
      
      const effectiveName = currentVal.trim() || saved; 
      const cleanName = sanitizeName(effectiveName);

      if (cleanName && inputEl) {
          inputEl.value = cleanName;
          applyNameLockUI(inputEl);
      }
      return cleanName;
    }

    async function autoSubmitIfPossible() {
      if (__submittedForThisOpen) return; 
      
      const inputEl = $("player-name-input"); 
      try { if (inputEl) inputEl.blur(); } catch(e){} 
      
      if (inputEl) {
          inputEl.readOnly = true;
          inputEl.disabled = true;
          inputEl.classList.add('nickname-locked');
      }
      
      await new Promise(res => setTimeout(res, 50));

      const rawValue = getFreshInputValue();
      logDebug("Submit Triggered", `Raw DOM Value: "${rawValue}"`);
      const name = sanitizeName(rawValue); const sc = window.__GAME_SCORE__ ?? 0;
      
      if (!name) { 
          setStatus("Enter your name to save score."); 
          if (inputEl) { inputEl.readOnly = false; inputEl.disabled = false; inputEl.classList.remove('nickname-locked'); }
          return; 
      }
      
      try { 
          localStorage.setItem("zr_player_name", name); 
          localStorage.setItem("zr_name_locked", "1"); 
          logDebug("LocalStorage Updated", name); 
      } catch(e){}
      
      __submittedForThisOpen = true;
      setStatus("Submitting...");

      __autoSubmitPromise = (async () => {
        const result = await submitScore(name, sc); lockName(name); 
        setStatus(result && result.written ? "Saved!" : `Best kept: ${result?.prevScore ?? 0}`); 
        // Trigger BOTH updates here
        await refreshTop10AndMyRank(name);
        return result;
      })().catch((e) => { 
          console.warn(e); 
          setStatus(e.message || "Submit failed."); 
          __submittedForThisOpen = false; 
      });
      return __autoSubmitPromise;
    }

    function bindUI() {
      const nameInput = $("player-name-input"); if (!nameInput) return;
      
      // Stop ALL keys from reaching Phaser
      const stopProp = (e) => { e.stopPropagation(); };

      nameInput.addEventListener("keydown", async (e) => { 
          e.stopPropagation();
          if (e.key === "Enter" || e.keyCode === 13) {
              if (e.isComposing) return; 
              e.preventDefault(); 
              logDebug("Key pressed", "ENTER (Immediate Submit)");
              await autoSubmitIfPossible();
          }
      });

      ['keypress', 'keyup'].forEach(evt => nameInput.addEventListener(evt, stopProp));
      ['pointerdown','pointerup','mousedown','mouseup','touchstart','touchend'].forEach(evt => nameInput.addEventListener(evt, stopProp));

      nameInput.addEventListener("input", (e) => { logDebug("Typing", e.target.value); });
      nameInput.addEventListener("blur", (e) => { 
          logDebug("Blur", e.target.value); 
          if (e.target.value.trim().length > 0 && !__submittedForThisOpen) { autoSubmitIfPossible(); } 
      });
      updateNameUI();
    }

    window.LeaderboardAPI = {
      open: async function ({ score, nameInputId }) {
        const inputEl = document.getElementById(nameInputId); prefillName(inputEl); window.__GAME_SCORE__ = score;
        __submittedForThisOpen = false; 
        bindUI(); 
        const name = updateNameUI(); 
        
        // Initial load (pass name to try loading my rank if exists)
        await refreshTop10AndMyRank(name);

        if (!isNameLocked()) {
             setStatus("Enter your name to save score."); try { if (inputEl) inputEl.focus(); } catch(e){} 
        } else {
             autoSubmitIfPossible();
        }
      },
      beforePlayAgain: async function () { return await (__autoSubmitPromise || autoSubmitIfPossible() || Promise.resolve()); },
      refreshTop10: () => refreshTop10AndMyRank(getFreshInputValue())
    };
    if (document.readyState === "loading") { document.addEventListener("DOMContentLoaded", bindUI); } else { bindUI(); }
    
    // Initial check (don't know name yet)
    refreshTop10AndMyRank(null);
    setStatus("Checking server...");
  })();
</script>


  <audio id="bgm" src="assets/BGM.m4a" preload="auto" loop playsinline></audio>

<!-- SFX Test UI (dev) -->
<div id="sfxTestBtn" style="
  position: fixed; right: 12px; bottom: 12px; z-index: 99999;
  font-family: monospace; font-size: 12px; line-height: 12px;
  padding: 10px 12px; border: 2px solid #ffd54a; border-radius: 10px;
  background: rgba(0,0,0,0.8); color: #ffd54a; cursor: pointer;
  user-select: none;
">SFX TEST</div>

<div id="sfxTestPanel" style="
  position: fixed; right: 12px; bottom: 60px; z-index: 99999;
  width: 260px; max-height: 60vh; overflow: auto;
  font-family: monospace; font-size: 12px;
  padding: 10px; border: 2px solid #ffd54a; border-radius: 10px;
  background: rgba(0,0,0,0.9); color: #fff; display: none;
">
  <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:8px;">
    <div style="color:#ffd54a; font-weight:bold;">SFX Preview</div>
    <div id="sfxTestClose" style="color:#ffd54a; cursor:pointer; padding:2px 6px;">✕</div>
  </div>
  <div id="sfxTestHint" style="opacity:0.9; margin-bottom:8px;">
    Click a sound to play. First click unlocks audio.
  </div>
  <div id="sfxTestList"></div>
</div>


<script>
// ===== SFX TEST UI (robust inject) =====
(function(){
  function ensureEl(id, tag){
    let el = document.getElementById(id);
    if(!el){
      el = document.createElement(tag||'div');
      el.id = id;
      document.body.appendChild(el);
    }
    return el;
  }

  function applyBtnStyle(el){
    el.textContent = 'SFX TEST';
    el.style.position = 'fixed';
    el.style.right = '12px';
    el.style.top = '12px';
    el.style.bottom = 'auto';
    el.style.zIndex = '2147483647';
    el.style.fontFamily = 'monospace';
    el.style.fontSize = '12px';
    el.style.lineHeight = '12px';
    el.style.padding = '10px 12px';
    el.style.border = '2px solid #ffd54a';
    el.style.borderRadius = '10px';
    el.style.background = 'rgba(0,0,0,0.85)';
    el.style.color = '#ffd54a';
    el.style.cursor = 'pointer';
    el.style.userSelect = 'none';
    el.style.pointerEvents = 'auto';
    el.style.display = 'block';
  }

  function applyPanelStyle(el){
    el.style.position = 'fixed';
    el.style.right = '12px';
    el.style.top = '52px';
    el.style.bottom = 'auto';
    el.style.zIndex = '2147483647';
    el.style.width = '260px';
    el.style.maxHeight = '70vh';
    el.style.overflow = 'auto';
    el.style.fontFamily = 'monospace';
    el.style.fontSize = '12px';
    el.style.padding = '10px';
    el.style.border = '2px solid #ffd54a';
    el.style.borderRadius = '10px';
    el.style.background = 'rgba(0,0,0,0.92)';
    el.style.color = '#fff';
    el.style.display = 'none';
    el.style.pointerEvents = 'auto';
  }

  function buildUI(panel){
    if(panel.dataset.built === '1') return;
    panel.dataset.built = '1';
    panel.innerHTML = `
      <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:8px;">
        <div style="color:#ffd54a; font-weight:bold;">SFX Preview</div>
        <div id="sfxTestClose2" style="color:#ffd54a; cursor:pointer; padding:2px 6px;">✕</div>
      </div>
      <div style="opacity:0.9; margin-bottom:8px;">Click a sound to play. First click unlocks audio.</div>
      <div id="sfxTestList2"></div>
    `;
  }

  const NAMES = [
    'ui_start','ui_click','enemy_hit','enemy_die','player_hit','ship_explode','explosion',
    'powerup_pickup','hp_pickup','letter_collect','turret_install','word_complete',
    'all_letters_complete','survive_success',
    'survival_fail','leaderboard_submit','leaderboard_rank_up'
  ];

  function hasFn(n){ return window.SFX && typeof window.SFX[n] === 'function'; }

  function play(n){
    try{
      if(window.SFX && typeof window.SFX.init === 'function') window.SFX.init();
      if(hasFn(n)) { console.log('[SFX TEST] play', n); window.SFX[n](); }
      else { console.log('[SFX TEST] missing', n); }
    }catch(e){ console.log('[SFX TEST] error', n, e && e.message ? e.message : e); }
  }

  function render(){
    const list = document.getElementById('sfxTestList2');
    if(!list) return;
    list.innerHTML = '';
    NAMES.forEach((n)=>{
      const row = document.createElement('div');
      row.style.display='flex';
      row.style.alignItems='center';
      row.style.justifyContent='space-between';
      row.style.gap='8px';
      row.style.padding='6px 4px';
      row.style.borderBottom='1px solid rgba(255,213,74,0.2)';

      const label = document.createElement('div');
      label.textContent = n;
      label.style.opacity = hasFn(n) ? '1' : '0.4';

      const b = document.createElement('button');
      b.textContent='Play';
      b.style.cursor='pointer';
      b.style.border='1px solid #ffd54a';
      b.style.background='rgba(255,213,74,0.1)';
      b.style.color='#ffd54a';
      b.style.borderRadius='8px';
      b.style.padding='4px 8px';
      b.style.fontFamily='monospace';
      b.style.fontSize='12px';
      b.disabled = !hasFn(n);
      b.addEventListener('click',(ev)=>{ev.stopPropagation(); play(n);});

      row.addEventListener('click',()=>play(n));
      row.appendChild(label);
      row.appendChild(b);
      list.appendChild(row);
    });
  }

  function init(){
    const btn = ensureEl('sfxTestBtn2','div');
    const panel = ensureEl('sfxTestPanel2','div');
    applyBtnStyle(btn);
    applyPanelStyle(panel);
    buildUI(panel);

    btn.addEventListener('pointerdown', (e)=>{
      e.preventDefault(); e.stopPropagation();
      const show = panel.style.display === 'none';
      panel.style.display = show ? 'block' : 'none';
      if(show) render();
    });

    panel.addEventListener('pointerdown', (e)=>{ e.stopPropagation(); });

    panel.addEventListener('click', (e)=>{
      const close = e.target && e.target.id === 'sfxTestClose2';
      if(close){ panel.style.display='none'; e.stopPropagation(); }
    });

    // debug visibility
    setTimeout(()=>{
      const r = btn.getBoundingClientRect();
      console.log('[SFX TEST] button ready', {x:r.x,y:r.y,w:r.width,h:r.height});
    }, 200);
  }

  if(document.readyState === 'loading') document.addEventListener('DOMContentLoaded', init);
  else init();
})();
</script>

</body>
</html>