<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Zombie Rollerz: Bigger Boomerang Hitbox</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        html, body { margin: 0; padding: 0; background: #000; width: 100%; height: 100%; overflow: hidden; font-family: 'Press Start 2P', monospace; letter-spacing: 0.5px; text-transform: uppercase; }
        canvas { display: block; margin: 0 auto; background: #000; }
        body { display: flex; justify-content: center; align-items: center; touch-action: none; color: #fff; }
        
        #game-wrapper { 
            position: relative; width: 100%; height: 100%; 
            max-width: 540px; aspect-ratio: 9/16; 
            background: #000; overflow: hidden; 
            box-shadow: 0 0 30px rgba(0,0,0,0.5); 
            border: 2px solid #666; 
        }
        canvas { display: block; width: 100%; height: 100%; }
        #rotate-msg { display: none; }

        /* === 结算界面主容器 === */
        #game-over-ui {
            display: none; 
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.94);
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            z-index: 100;
            color: white;
            text-align: center;
            font-family: 'Press Start 2P', monospace !important;
            padding: 20px 5%; 
            padding-bottom: 40px; 
            box-sizing: border-box; 
        }
        
        /* === 上半部分 === */
        #go-top-section {
            width: 100%; 
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            margin-bottom: 10px; 
            flex-shrink: 0;
        }

        #go-title { display: none !important; }
        
        .score-row { 
            display: flex; gap: 12px; font-size: 14px; margin: 5px 0; color: #ddd; 
            flex-wrap: nowrap; white-space: nowrap; 
        }
        .highlight { color: #FFD700; font-weight: bold; font-size: 16px; }
        
        #input-area { margin-top: 8px; margin-bottom: 8px; }
        
        input[type="text"] {
            padding: 10px; font-size: 12px; text-align: center;
            border: 2px solid #FFD700; border-radius: 5px; 
            background: #222; color: white; width: 200px;
            font-family: 'Press Start 2P', monospace;
            transition: all 0.3s;
        }
        #player-name-input.nickname-locked {
            border-color: transparent !important;
            background-color: transparent !important;
            color: #FFFFFF !important;
            opacity: 1; pointer-events: none;
            text-shadow: 0 2px 0 #000;
        }

        button#restart-btn {
            padding: 12px 24px; font-size: 13px; font-weight: bold;
            background: #FF4500; color: white; border: none; border-radius: 5px;
            cursor: pointer; transition: transform 0.1s; min-width: 180px; 
            font-family: 'Press Start 2P', monospace;
            box-shadow: 0 4px 0 #b33200;
        }
        button#restart-btn:active { transform: scale(0.95); box-shadow: 0 2px 0 #b33200; transform: translateY(2px); }

        /* 分割线 */
        .section-divider {
            width: 90%; height: 2px; background-color: #444;
            margin: 20px 0 15px 0; flex-shrink: 0;
        }

        /* === 下半部分 === */
        #leaderboard-section {
            width: 100%; flex: 1; 
            display: flex; flex-direction: column; 
            align-items: center; overflow: hidden; min-height: 0;
        }

        .lb-main-title {
            color: #FFD700; font-size: 16px; margin: 0 0 10px 0; text-shadow: 0 2px 0 #000;
        }

        .lb-sub-label {
            width: 95%; max-width: 420px;
            text-align: left; font-size: 10px; color: #888;
            margin-top: 5px; margin-bottom: 5px; letter-spacing: 1px;
        }

        #lb-status { color:#bbb; font-size:10px; margin: 2px 0; min-height: 12px; }

        /* 列表 */
        #lb-top10 { 
            width: 95%; max-width: 420px; 
            flex: 1; overflow-y: auto; 
            display:flex; flex-direction:column; gap: 6px; padding-right: 2px;
        }

        /* 行样式 */
        .lb-item {
            display:flex; justify-content:space-between; align-items:center;
            padding: 12px 14px; border-radius: 6px;
            border: 1px solid rgba(255,255,255,0.1);
            background: rgba(0,0,0,0.4);
            font-size: 12px; line-height: 1.5; flex-shrink: 0;
        }
        .lb-left { display:flex; gap:10px; align-items:center; overflow:hidden; }
        .lb-rank { min-width: 32px; color:#FFD700; font-weight: 900; }
        .lb-name { 
            color:#fff; font-weight: 800; 
            white-space:nowrap; overflow:hidden; text-overflow:ellipsis; 
            max-width: 150px; 
        }
        .lb-score { color:#FFD700; font-weight: 900; margin-left: auto; }

        /* 我的排名 */
        #lb-my-rank-container {
            width: 95%; max-width: 420px; flex-shrink: 0;
            margin-bottom: 12px; min-height: 40px;
        }
        .my-rank-row {
            background: rgba(184, 134, 11, 0.7) !important;
            border: 1px solid #FFD700 !important; 
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.2);
        }

        #happy-sprite-text {
            display: flex; justify-content: center; align-items: center;
            flex-wrap: nowrap; gap: 0px; margin-bottom: 10px;
            width: 100%; transform: scale(1.0); 
        }
        .hny-letter { background-repeat: no-repeat; image-rendering: pixelated; flex: 0 0 auto; }
        .hny-space { flex: 0 0 auto; height: 1px; }

        #go-title, #name-display-area, #lb-myline { display: none !important; }
        
        #debug-btn {
            position: absolute; bottom: 5px; left: 5px; z-index: 500;
            padding: 6px 10px; background: rgba(0, 0, 0, 0.6);
            color: #00FF00; border: 1px solid #00FF00;
            font-family: monospace; font-size: 12px; pointer-events: auto;
        }

        @media screen and (orientation: landscape) and (max-width: 900px) {
            #game-wrapper { display: none; }
            #rotate-msg { display: block; text-align: center; font-size: 20px; margin-top: 20%; color: #fff; }
        }
    </style>
    
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
    <script>
    (function(){
      window.addEventListener('DOMContentLoaded', () => {
          const input = document.getElementById('player-name-input');
          if (!input) return;
          try{
            const saved = localStorage.getItem('playerNickname'); 
            const saved2 = localStorage.getItem('zr_player_name');
            const locked = localStorage.getItem('zr_name_locked') === "1";
            if ((saved && saved.trim().length > 0) || (saved2 && saved2.trim().length > 0)){
              input.value = saved2 || saved;
              if (locked) {
                  input.classList.add('nickname-locked');
                  input.readOnly = true; input.disabled = true;
              }
            }
          }catch(e){}
      });
    })();
    </script>
</head>
<body>

<div id="rotate-msg">请旋转手机使用竖屏游玩<br>Please Rotate to Portrait</div>

<div id="game-wrapper">
    <div id="game-container"></div>
    <button id="debug-btn">DEBUG: OFF</button>

    <div id="game-over-ui">
        <!-- 上部 -->
        <div id="go-top-section">
            <h1 id="go-title"></h1>
            <div id="happy-sprite-text"></div>
            <div id="name-display-area" style="display:none;"></div>
            
            <div class="score-row">
                <div>Score: <span id="go-score" class="highlight">0</span></div>
                <div>Best: <span id="go-best" class="highlight">0</span></div>
            </div>
            <div style="font-size: 16px; color: #FF0000; margin-bottom: 5px;" id="go-letters"></div>
            <div id="input-area">
                <input type="text" id="player-name-input" placeholder="Enter Name" maxlength="12">
            </div>
            <div id="go-button-row">
                <button id="restart-btn">PLAY AGAIN</button>
            </div>
        </div>
        
        <div class="section-divider"></div>
        
        <div id="leaderboard-section">
            <h2 class="lb-main-title">GLOBAL RANKING</h2>
            <div id="lb-status">Checking...</div>
            
            <div class="lb-sub-label">YOUR POSITION</div>
            <div id="lb-my-rank-container"></div>
            
            <div class="lb-sub-label">TOP PLAYERS</div>
            <div id="lb-top10"></div>
        </div>
    </div>
</div>

<script>
const DEBUG_SLOTS = false; 

function renderHappyNewYearSpritesDOM(collectedIndexSet) {
    const container = document.getElementById('happy-sprite-text');
    if (!container) return;
    const total = 12; 
    const scale = 0.26;
    const fw = 110, fh = 128;
    const cols = 4, rows = 3;
    const w = Math.round(fw * scale);
    const h = Math.round(fh * scale);
    const sheetW = Math.round((fw * cols) * scale);
    const sheetH = Math.round((fh * rows) * scale);

    container.innerHTML = '';
    for (let i = 0; i < total; i++) {
        if (i === 5 || i === 8) {
            const sp = document.createElement('div');
            sp.className = 'hny-space';
            sp.style.width = Math.round(18 * scale) + 'px';
            container.appendChild(sp);
        }
        const col = i % 4;
        const row = Math.floor(i / 4);
        const el = document.createElement('div');
        el.className = 'hny-letter';
        el.style.width = w + 'px';
        el.style.height = h + 'px';
        const collected = collectedIndexSet && collectedIndexSet.has && collectedIndexSet.has(i);
        if (collected) {
            el.style.backgroundImage = "url('assets/text_happynewyear.png')";
            el.style.backgroundSize = `${sheetW}px ${sheetH}px`;
            el.style.backgroundPosition = `${-col * w}px ${-row * h}px`;
        } else {
            el.style.backgroundImage = "url('assets/text_question.png')";
            el.style.backgroundSize = 'contain';
            el.style.backgroundPosition = 'center';
        }
        container.appendChild(el);
    }
}

const CONFIG = {
    PLAYER_SCALE: 0.85, 
    SPEED_PLAYER: 150,    
    SPEED_ZOMBIE_BASE: 100, 
    HP_ZOMBIE_BASE: 10,     
    BULLET_SPEED: 1500,   
    FIRE_RATE: 25,       
    HP_TRAMPLE_COST: 5,
    COMBO_TIMEOUT: 2500,
    MAGNET_DIST: 400, 
    MAGNET_SPEED: 600, 
    LIMIT_POWERUP: 8,
    LIMIT_HEART: 10,
    BOOMERANG_RADIUS: 140, 
    BOOMERANG_SPEED: 0.15, 
    DAMAGE_BOOMERANG: 5,
    DAMAGE_CANNON: 5,
    CANNON_AOE_RADIUS: 120, 
    CANNON_KNOCKBACK: 600,
    CANNON_STUN_DURATION: 500,
    HIT_STUN_DURATION: 100 
};

const COLORS = {
    PLAYER_BODY: 0x888888, PLAYER_DECK: 0xAAAAAA, 
    WHEEL: 0x222222, WHEEL_TREAD: 0x000000, 
    TURRET: 0xFFD700, HEART:  0xFF1493, LETTER: '#FF0000',     
    BULLET: 0xFF8C00, ARROW:  0x333333,
    POWERUP_BG: 0x800080, POWERUP_TEXT: '#FFFFFF',
    HAPPY: 0xFFD700, BOOMERANG_RING: 0xFFFF00,
    CANNON_ICON: 0xFFD700, CANNON_BALL: 0xFFFF00, 
    EXPLOSION: 0xFF4500, TRAIL_COLOR: 0xFF6600, TRAIL_BASE: 0xFFFFFF 
};

const gameConfig = {
    type: Phaser.AUTO, 
    scale: { mode: Phaser.Scale.FIT, autoCenter: Phaser.Scale.CENTER_BOTH, width: 540, height: 960 },
    parent: 'game-container',
    backgroundColor: '#f7ce65',
    physics: { default: 'arcade', arcade: { debug: false, gravity: { y: 0 }, fps: 60 } },
    fps: { target: 60, min: 30 },
    scene: { preload: preload, create: create, update: update },
    pixelArt: true
};

const game = new Phaser.Game(gameConfig);

// Globals
let player, directionArrow;
let playerShadow; 
let wheelLeft, wheelRight, wheelLeftShadow, wheelRightShadow;
let wheelsGroup; 
let cursors, joystickBase, joystickStick;
let isTouching = false, touchStartPoint = { x: 0, y: 0 };
let enemies, bullets, pickups, boomerangs;
let explosionEmitter; 
let debugGraphics; 
let hitboxGraphics; 

let isDebugMode = false;
let gameStarted = false;
let startLogo, startText;

let lastWheelPosLeft = null;
let lastWheelPosRight = null;

let turretSlotsDef = [
    { x: 0,   y: -106 }, 
    { x: -60, y: -50 }, 
    { x: 60,  y: -50 }, 
    { x: -60, y: 44 }, 
    { x: 60,  y: 44 }, 
    { x: 0,   y: 106 } 
];

let turretSlots = []; 
let activeTurrets = [];
let score = 0, gameTime = 60, hp = 100, maxHp = 100;
let highScore = 0;
let targetLetters = "HAPPYNEWYEAR".split('');
let collectedIndices = [];
let droppedLetterIndices = []; 
let damagePerShot = 1; 
let droppedCounts = { powerup: 0, heart: 0 };
let comboCount = 0;
let comboTimerEvent = null;
// UI Elements
let timeText, timeDigitTens, timeDigitOnes, hpText, scoreText, highScoreText, letterText, fpsText, debugText;
let hudBg = null;
let uiIntroTargets = null;
let clockIcon, hpIcon;

let hnyHudSprites = null;
let comboText, comboScaleTween; 
let gameOver = false;
let shipDestroyedSequence = false;

let timerEvent, fireEvent;
let boomerangGlobalAngle = 0;

function preload() {
    this.load.spritesheet('zombie_sheet', 'assets/zombie.png', { frameWidth: 128, frameHeight: 128 });
    this.load.image('playerTex', 'assets/boat.png');
    this.load.spritesheet('explosion8', 'assets/ark_explosion.png', { frameWidth: 128, frameHeight: 128 });
    this.load.spritesheet('hnyLetters', 'assets/text_happynewyear.png', { frameWidth: 110, frameHeight: 128 });
    this.load.spritesheet('countdownNumbers', 'assets/text_number.png', { frameWidth: 110, frameHeight: 128 });
    this.load.image('questionMark', 'assets/text_question.png');
    this.load.image('textPowerup', 'assets/text_powerup.png');
    this.load.image('textHP', 'assets/text_HP+.png');
    this.load.spritesheet('wheelAnim', 'assets/wheel_anim.png', { frameWidth: 256, frameHeight: 345 });
    this.load.spritesheet('powerupSheet', 'assets/powup_anim.png', { frameWidth: 89, frameHeight: 89 });
    this.load.spritesheet('heartSheet', 'assets/heart_anim.png', { frameWidth: 89, frameHeight: 89 });
    this.load.image('wheelShadowTex', 'assets/wheel_shadow.png');
    this.load.spritesheet('gun8dir', 'assets/machinegun.png', { frameWidth: 128, frameHeight: 128 });
    this.load.spritesheet('cannon8dir', 'assets/cannon.png', { frameWidth: 128, frameHeight: 128 });
    this.load.spritesheet('boomerang8dir', 'assets/boomerang.png', { frameWidth: 128, frameHeight: 128 });
    this.load.image('boomerangProjectile', 'assets/boomerang_projectile.png');
    this.load.image('boomerangShadowTex', 'assets/boomerang_projectile_shadow.png');
    this.load.image('bulletTex', 'assets/bullet.png');
    this.load.image('cannonBallTex', 'assets/bomb.png');
    this.load.spritesheet('explosionAnim', 'assets/explosion.png', { frameWidth: 128, frameHeight: 128 });
    this.load.spritesheet('zombie_death', 'assets/zombie_death.png', { frameWidth: 128, frameHeight: 128 });
    this.load.image('gameLogo', 'assets/logo.png');
    this.load.spritesheet('groundTiles', 'assets/tiles.png', { frameWidth: 128, frameHeight: 128 });
    this.load.image('playerShadowTex', 'assets/shadow.png');
    this.load.image('trackTex', 'assets/track.png');
    
    // Add custom clock icon (or auto-generated later if not found)
    // this.load.image('clockIcon', 'assets/clock.png'); // Uncomment if file exists
}

function setActionLog(msg) {
    if(debugText) debugText.lastAction = msg;
}

function loadHighScore() {
    try {
        const saved = localStorage.getItem('zr_highscore');
        if (saved) highScore = parseInt(saved, 10);
    } catch (e) {}
}

function saveHighScore(newScore) {
    if (newScore > highScore) {
        highScore = newScore;
        try { localStorage.setItem('zr_highscore', highScore); } catch (e) {}
    }
}

function create() {
    loadHighScore();
    setupDomEvents();
    generateTextures(this); 
    
    createZombieAnimations(this);

    if (!this.anims.exists('explosion_play')) {
        this.anims.create({
            key: 'explosion_play',
            frames: this.anims.generateFrameNumbers('explosion8', { start: 0, end: 7 }),
            frameRate: 14,
            repeat: 0
        });
    }

    const spinFrames = [1, 2, 5, 8, 7, 6, 3, 0];
    this.anims.create({ key: 'spin_gun', frames: this.anims.generateFrameNumbers('gun8dir', { frames: spinFrames }), frameRate: 6, repeat: -1 });
    this.anims.create({ key: 'spin_cannon', frames: this.anims.generateFrameNumbers('cannon8dir', { frames: spinFrames }), frameRate: 6, repeat: -1 });
    this.anims.create({ key: 'spin_boomerang', frames: this.anims.generateFrameNumbers('boomerang8dir', { frames: spinFrames }), frameRate: 6, repeat: -1 });
    this.anims.create({ key: 'spin_powerup', frames: this.anims.generateFrameNumbers('powerupSheet', { frames: [0,1,2,3,5,6,7,8] }), frameRate: 6, repeat: -1 });
    this.anims.create({ key: 'spin_heart', frames: this.anims.generateFrameNumbers('heartSheet', { frames: [0,1,2,3,5,6,7,8] }), frameRate: 6, repeat: -1 });

    this.anims.create({
        key: 'wheel_roll',
        frames: this.anims.generateFrameNumbers('wheelAnim', { start: 0, end: 2 }),
        frameRate: 15,
        repeat: -1
    });

    this.anims.create({
        key: 'explode',
        frames: this.anims.generateFrameNumbers('explosionAnim', { start: 0, end: 35 }),
        frameRate: 60,
        hideOnComplete: true
    });

    this.physics.world.setBounds(0, 0, 2000, 2000);
    this.cameras.main.setBounds(0, 0, 2000, 2000);
    
    for (let i = 0; i < 16; i++) {
        const x = Phaser.Math.Between(0, 2000);
        const y = Phaser.Math.Between(0, 2000);
        const frame = Phaser.Math.Between(0, 15);
        const decor = this.add.sprite(x, y, 'groundTiles', frame);
        decor.setDepth(-1); 
    }

    const WHEEL_SCALE_FIX = 0.6; 
    const finalWheelScale = WHEEL_SCALE_FIX * CONFIG.PLAYER_SCALE;

    wheelsGroup = this.physics.add.group();

    wheelLeftShadow = this.add.sprite(1000, 1000, 'wheelShadowTex').setDepth(2);
    wheelLeftShadow.setFlipX(true);
    wheelLeftShadow.setScale(finalWheelScale);
    wheelLeftShadow.alpha = 0.5;

    wheelRightShadow = this.add.sprite(1000, 1000, 'wheelShadowTex').setDepth(2);
    wheelRightShadow.setFlipX(false);
    wheelRightShadow.setScale(finalWheelScale);
    wheelRightShadow.alpha = 0.5;

    wheelLeft = this.physics.add.sprite(1000, 1000, 'wheelAnim').setDepth(9);
    wheelLeft.setFlipX(true); 
    wheelLeft.setScale(finalWheelScale); 
    wheelLeft.body.setSize(180, 280); 
    wheelsGroup.add(wheelLeft);

    wheelRight = this.physics.add.sprite(1000, 1000, 'wheelAnim').setDepth(9);
    wheelRight.setFlipX(false);
    wheelRight.setScale(finalWheelScale);
    wheelRight.body.setSize(180, 280); 
    wheelsGroup.add(wheelRight);

    playerShadow = this.add.sprite(1000, 1000, 'playerShadowTex');
    playerShadow.setDepth(2);
    playerShadow.setScale(CONFIG.PLAYER_SCALE); 
    playerShadow.alpha = 0.5;

    player = this.physics.add.sprite(1000, 1000, 'playerTex');
    player.setScale(CONFIG.PLAYER_SCALE);
    player.rotation = -Math.PI / 2; 

    lastWheelPosLeft = new Phaser.Math.Vector2(wheelLeft.x, wheelLeft.y);
    lastWheelPosRight = new Phaser.Math.Vector2(wheelRight.x, wheelRight.y);

    turretSlots = turretSlotsDef.map(slot => ({
        x: slot.x * CONFIG.PLAYER_SCALE,
        y: slot.y * CONFIG.PLAYER_SCALE,
        occupied: false,
        sprite: null
    }));

    const bodyW = 140 * CONFIG.PLAYER_SCALE; 
    const bodyH = 300 * CONFIG.PLAYER_SCALE; 
    player.body.setSize(bodyW, bodyH); 
    
    player.setCollideWorldBounds(true);
    player.setDepth(10);
    
    this.cameras.main.startFollow(player, true, 0.1, 0.1);
    this.cameras.main.setZoom(0.8);

    if (DEBUG_SLOTS) {
        debugGraphics = this.add.graphics().setDepth(100);
    }
    hitboxGraphics = this.add.graphics().setDepth(1000);
    setupDebugBtn(this);

    directionArrow = this.add.sprite(player.x, player.y, 'arrowTex').setDepth(20).setVisible(false);
    directionArrow.rotation = -Math.PI / 2;

    enemies = this.physics.add.group({ runChildUpdate: false, bounceX: 0, bounceY: 0, dragX: 500, dragY: 500 }); 
    this.physics.add.collider(enemies, enemies);

    bullets = this.physics.add.group({ defaultKey: 'bulletTex', maxSize: 800, runChildUpdate: false });
    boomerangs = this.physics.add.group({ runChildUpdate: false, allowGravity: false, immovable: true });
    pickups = this.physics.add.group();

    this.physics.add.collider(enemies, pickups, null, (enemy, pickup) => {
        return pickup.dropType === 'TURRET' && !pickup.isMagneting;
    });

    explosionEmitter = this.add.particles(0, 0, 'bulletTex', {
        lifespan: 300, speed: { min: 100, max: 200 }, scale: { start: 1, end: 0 },
        quantity: 8, emitting: false 
    });
    explosionEmitter.setDepth(15);

    cursors = this.input.keyboard.createCursorKeys();
    this.input.keyboard.addKeys('W,A,S,D');
    this.input.addPointer(1);
    setupVirtualJoystick(this);

    addTurret(this);
    createUI(this);

    this.physics.add.overlap(bullets, enemies, hitEnemy, null, this);
    this.physics.add.overlap(boomerangs, enemies, hitEnemyByBoomerang, null, this);
    this.physics.add.overlap(player, enemies, handleTrample, null, this);
    this.physics.add.overlap(wheelsGroup, enemies, handleTrample, null, this);
    this.physics.add.overlap(player, pickups, collectPickup, null, this);

    gameStarted = false;
    createStartScreen(this);
}

function createStartScreen(scene) {
    const screenWidth = scene.cameras.main.width;
    const screenHeight = scene.cameras.main.height;
    startLogo = scene.add.sprite(screenWidth / 2, screenHeight * 0.15, 'gameLogo');
    startLogo.setScrollFactor(0);
    startLogo.setDepth(1000);
    startLogo.displayWidth = screenWidth * 1.05;
    startLogo.scaleY = startLogo.scaleX; 
    const isDesktop = scene.sys.game.device.os.desktop;
    const textStr = isDesktop ? "Tap W/S/A/D to start" : "Drag to start";
    startText = scene.add.text(screenWidth / 2, screenHeight * 0.85, textStr, {
        fontSize: '21px',
        fontFamily: 'Press Start 2P',
        fontStyle: 'bold',
        color: '#FFFFFF',
        stroke: '#000000',
        strokeThickness: 4,
        align: 'center'
    }).setOrigin(0.5).setScrollFactor(0).setDepth(1000);
    scene.tweens.add({ targets: startText, alpha: 0.5, duration: 800, yoyo: true, repeat: -1 });
}

function startGameLogic(scene) {
    if (gameStarted) return;
    gameStarted = true;
    scene.tweens.add({ targets: startText, alpha: 0, duration: 300, onComplete: () => startText.destroy() });
    scene.tweens.add({ targets: startLogo, y: -200, duration: 1000, ease: 'Back.in', onComplete: () => startLogo.setVisible(false) });
    scene.time.delayedCall(1000, () => runHUDIntro(scene));
spawnZombieWave(scene);
    timerEvent = scene.time.addEvent({ delay: 1000, callback: updateTimer, callbackScope: scene, loop: true });
    fireEvent = scene.time.addEvent({ delay: CONFIG.FIRE_RATE, callback: fireTurrets, callbackScope: scene, loop: true });
}

function checkGameStart(scene) {
    const keys = scene.input.keyboard.createCursorKeys();
    const wasd = scene.input.keyboard.addKeys('W,A,S,D');
    const anyKeyPress = keys.left.isDown || keys.right.isDown || keys.up.isDown || keys.down.isDown ||
                        wasd.W.isDown || wasd.A.isDown || wasd.S.isDown || wasd.D.isDown;
    const pointerDown = scene.input.activePointer.isDown;
    if (anyKeyPress || pointerDown) {
        startGameLogic(scene);
    }
}

function createZombieAnimations(scene) {
    const frameRate = 8;
    scene.anims.create({ key: 'z_down', frames: scene.anims.generateFrameNumbers('zombie_sheet', { frames: [0, 4, 8, 12] }), frameRate: frameRate, repeat: -1 });
    scene.anims.create({ key: 'z_up', frames: scene.anims.generateFrameNumbers('zombie_sheet', { frames: [1, 5, 9, 13] }), frameRate: frameRate, repeat: -1 });
    scene.anims.create({ key: 'z_left', frames: scene.anims.generateFrameNumbers('zombie_sheet', { frames: [2, 6, 10, 14] }), frameRate: frameRate, repeat: -1 });
    scene.anims.create({ key: 'z_right', frames: scene.anims.generateFrameNumbers('zombie_sheet', { frames: [3, 7, 11, 15] }), frameRate: frameRate, repeat: -1 });
    scene.anims.create({ key: 'death_1', frames: scene.anims.generateFrameNumbers('zombie_death', { start: 0, end: 3 }), frameRate: 7, repeat: 0 });
    scene.anims.create({ key: 'death_2', frames: scene.anims.generateFrameNumbers('zombie_death', { start: 4, end: 7 }), frameRate: 7, repeat: 0 });
}

function setupDebugBtn(scene) {
    const debugBtn = document.getElementById('debug-btn');
    if (debugBtn) {
        const newBtn = debugBtn.cloneNode(true);
        debugBtn.parentNode.replaceChild(newBtn, debugBtn);
        newBtn.addEventListener('click', () => {
            isDebugMode = !isDebugMode;
            newBtn.innerText = `DEBUG: ${isDebugMode ? 'ON' : 'OFF'}`;
            newBtn.style.color = isDebugMode ? '#00FF00' : '#888';
            newBtn.style.borderColor = isDebugMode ? '#00FF00' : '#888';
            scene.physics.world.drawDebug = isDebugMode;
            if (!scene.physics.world.debugGraphic) {
                scene.physics.world.createDebugGraphic();
            }
            scene.physics.world.debugGraphic.clear(); 
        });
    }
}

function setupDomEvents() {
    const restartBtn = document.getElementById('restart-btn');
    if (restartBtn) {
        const newBtn = restartBtn.cloneNode(true);
        restartBtn.parentNode.replaceChild(newBtn, restartBtn);
        newBtn.addEventListener('click', async () => {
            const nameInput = document.getElementById('player-name-input');
            const typed = (nameInput && nameInput.value) ? nameInput.value.trim() : "";
            let saved = "";
            try { saved = (localStorage.getItem('zr_player_name') || localStorage.getItem('lb_name') || "").trim(); } catch(e){}
            const finalName = typed || saved;
            if (!finalName) {
                try {
                    if (nameInput) { nameInput.focus(); }
                    const st = document.getElementById('lb-status');
                    if (st) st.textContent = "Enter your name to save score.";
                } catch(e){}
                return;
            }
            if (typed) {
                try { localStorage.setItem('zr_player_name', typed); } catch(e){}
            }
            try {
                const api = window.LeaderboardAPI;
                if (api && typeof api.beforePlayAgain === 'function') {
                    await Promise.race([
                        api.beforePlayAgain(),
                        new Promise(res => setTimeout(res, 1200))
                    ]);
                }
            } catch(e){}
            location.reload();
        });
    }
}

function update(time, delta) {
    if (gameOver) return;
    updateVisuals(time);
    if (!gameStarted) {
        checkGameStart(this);
        return;
    }
    handlePlayerMovement(this, time);
    handlePickupsMagnet(this);
    updateWheelTrack(this, wheelLeft, lastWheelPosLeft);
    updateWheelTrack(this, wheelRight, lastWheelPosRight);

    enemies.getChildren().forEach(enemy => {
        if (!enemy.active) return;
        if (enemy.shadow && enemy.shadow.active) {
            enemy.shadow.setPosition(enemy.x, enemy.y + 20); 
        }
        if (enemy.isDying) return;
        const angle = Phaser.Math.Angle.Between(enemy.x, enemy.y, player.x, player.y);
        const deg = Phaser.Math.RadToDeg(angle);
        if (deg > -45 && deg <= 45) enemy.play('z_right', true);
        else if (deg > 45 && deg <= 135) enemy.play('z_down', true);
        else if (deg > -135 && deg <= -45) enemy.play('z_up', true);
        else enemy.play('z_left', true);

        if (enemy.stunUntil && time < enemy.stunUntil) { } else {
            this.physics.moveTo(enemy, player.x, player.y, enemy.speed);
        }
    });

    if (isDebugMode) {
        if (hitboxGraphics) {
            hitboxGraphics.clear();
            if (player.body) {
                hitboxGraphics.fillStyle(0x00FF00, 0.6); 
                hitboxGraphics.fillRect(player.body.x, player.body.y, player.body.width, player.body.height);
            }
            hitboxGraphics.fillStyle(0x00FFFF, 0.6);
            if (wheelLeft.body) hitboxGraphics.fillRect(wheelLeft.body.x, wheelLeft.body.y, wheelLeft.body.width, wheelLeft.body.height);
            if (wheelRight.body) hitboxGraphics.fillRect(wheelRight.body.x, wheelRight.body.y, wheelRight.body.width, wheelRight.body.height);
        }
    } else {
        if (hitboxGraphics) hitboxGraphics.clear();
        if (debugGraphics) debugGraphics.clear();
    }
    
    // MODIFIED: Update HUD Text
    hpText.setText(`x${Math.max(0,Math.floor(hp))}`); 
    
    // Zero-pad the score to 6 digits (e.g. 000123)
    let sStr = String(score).padStart(6, '0');
    scoreText.setText(`SCORE: ${sStr}`);

    updateDebugInfo();
}

function updateWheelTrack(scene, wheel, lastPosVec) {
    const dist = Phaser.Math.Distance.Between(lastPosVec.x, lastPosVec.y, wheel.x, wheel.y);
    const step = 8; 
    if (dist > step) {
        let count = Math.floor(dist / step);
        const angle = Math.atan2(wheel.y - lastPosVec.y, wheel.x - lastPosVec.x);
        for (let i = 0; i < count; i++) {
            lastPosVec.x += Math.cos(angle) * step;
            lastPosVec.y += Math.sin(angle) * step;
            spawnTireTrack(scene, lastPosVec.x, lastPosVec.y, angle);
        }
    }
}

function spawnTireTrack(scene, x, y, angleRad) {
    const track = scene.add.sprite(x, y, 'trackTex');
    track.setDepth(0); 
    track.setRotation(angleRad + Math.PI / 2); 
    track.setScale(1.2); 
    track.alpha = 0.6; 
    scene.tweens.add({ targets: track, alpha: 0, duration: 10000, onComplete: () => track.destroy() });
}

function updateDebugInfo() {
    // MODIFIED: Debug info removed
    if(!debugText) return;
}

function handlePickupsMagnet(scene) {
    pickups.getChildren().forEach(drop => {
        if (!drop.active) return;
        if (drop.shadow && drop.shadow.active) {
            drop.shadow.setPosition(drop.x, drop.y + 25);
        }
        if (drop.dropType === 'LETTER') return;
        if (!drop.canMagnet) return;
        const dist = Phaser.Math.Distance.Between(drop.x, drop.y, player.x, player.y);
        if (dist <= CONFIG.MAGNET_DIST && !drop.isMagneting) {
            drop.isMagneting = true;
            scene.tweens.killTweensOf(drop); 
        }
        if (drop.isMagneting) {
            scene.physics.moveToObject(drop, player, CONFIG.MAGNET_SPEED);
        }
    });
}

function updateVisuals(time) {
    directionArrow.x = player.x;
    directionArrow.y = player.y;
    const isMoving = player.body.velocity.length() > 10;
    if (isMoving) {
        directionArrow.setVisible(true);
        directionArrow.setRotation(player.body.velocity.angle());
    } else {
        directionArrow.setVisible(false);
    }
    let angle = isMoving ? player.body.velocity.angle() : (directionArrow.rotation || 0);
    
    if (isMoving) {
        if (wheelLeft.anims.currentAnim?.key !== 'wheel_roll' || !wheelLeft.anims.isPlaying) {
            wheelLeft.play('wheel_roll');
            wheelRight.play('wheel_roll');
        }
    } else {
        if (wheelLeft.anims.isPlaying) {
            wheelLeft.stop();
            wheelRight.stop();
        }
    }

    let suspensionOffset = isMoving ? Math.sin(time * 0.02) * 3 : 0;
    const sideDist = 100 * CONFIG.PLAYER_SCALE; 
    
    const cosA = Math.cos(angle);
    const sinA = Math.sin(angle);
    
    wheelLeft.x = player.x + ((-suspensionOffset) * cosA - (-sideDist) * sinA);
    wheelLeft.y = player.y + ((-suspensionOffset) * sinA + (-sideDist) * cosA);
    wheelLeft.rotation = angle + Math.PI / 2; 

    wheelRight.x = player.x + ((suspensionOffset) * cosA - (sideDist) * sinA);
    wheelRight.y = player.y + ((suspensionOffset) * sinA + (sideDist) * cosA);
    wheelRight.rotation = angle + Math.PI / 2;

    wheelLeftShadow.x = wheelLeft.x;
    wheelLeftShadow.y = wheelLeft.y + 10;
    wheelLeftShadow.rotation = wheelLeft.rotation;

    wheelRightShadow.x = wheelRight.x;
    wheelRightShadow.y = wheelRight.y + 10;
    wheelRightShadow.rotation = wheelRight.rotation;

    const isHorizontal = Math.abs(Math.sin(wheelLeft.rotation)) > 0.707;
    const wVert = 180;
    const hVert = 280;
    if (isHorizontal) {
        if (wheelLeft.body.width !== hVert) {
            wheelLeft.body.setSize(hVert, wVert, true);
            wheelRight.body.setSize(hVert, wVert, true);
        }
    } else {
        if (wheelLeft.body.width !== wVert) {
            wheelLeft.body.setSize(wVert, hVert, true);
            wheelRight.body.setSize(wVert, hVert, true);
        }
    }
    
    player.rotation = isMoving ? Math.sin(time * 0.025) * 0.03 : 0;
    playerShadow.x = player.x; 
    playerShadow.y = player.y + 10; 
    playerShadow.rotation = player.rotation; 

    const rads = player.rotation;
    const cR = Math.cos(rads);
    const sR = Math.sin(rads);

    if (isDebugMode && debugGraphics) {
        debugGraphics.clear();
        debugGraphics.fillStyle(0x00FF00, 0.8);
        turretSlots.forEach(slot => {
            const rx = slot.x * cR - slot.y * sR;
            const ry = slot.x * sR + slot.y * cR;
            debugGraphics.fillCircle(player.x + rx, player.y + ry, 5);
        });
    }

    let validTargets = enemies.getChildren().filter(e => e.active && !e.isDying && Phaser.Math.Distance.Between(player.x, player.y, e.x, e.y) < 700);
    validTargets.sort((a, b) => {
        const distA = Phaser.Math.Distance.Between(player.x, player.y, a.x, a.y);
        const distB = Phaser.Math.Distance.Between(player.x, player.y, b.x, b.y);
        return distA - distB;
    });

    activeTurrets.forEach((tInfo, index) => {
        const turret = tInfo.sprite;
        const rx = tInfo.offsetX * cR - tInfo.offsetY * sR;
        const ry = tInfo.offsetX * sR + tInfo.offsetY * cR;
        
        turret.x = player.x + rx;
        turret.y = player.y + ry;

        if (tInfo.type === 'GUN' || tInfo.type === 'CANNON' || tInfo.type === 'BOOMERANG') {
            let target = null;
            if (tInfo.type === 'GUN' && validTargets.length > 0) {
                target = validTargets[index % validTargets.length];
                tInfo.hasTarget = true;
            } else if ((tInfo.type === 'CANNON' || tInfo.type === 'BOOMERANG') && validTargets.length > 0) {
                target = validTargets[0];
                tInfo.hasTarget = true;
                tInfo.targetEntity = target;
            } else {
                tInfo.hasTarget = false;
                tInfo.targetEntity = null;
            }

            if (tInfo.hasTarget && target) {
                tInfo.targetAngle = Phaser.Math.Angle.Between(turret.x, turret.y, target.x, target.y);
                const deg = Phaser.Math.RadToDeg(tInfo.targetAngle);
                let frameIndex = 7; 
                if (deg >= -22.5 && deg < 22.5) frameIndex = 5;       
                else if (deg >= 22.5 && deg < 67.5) frameIndex = 8;   
                else if (deg >= 67.5 && deg < 112.5) frameIndex = 7;  
                else if (deg >= 112.5 && deg < 157.5) frameIndex = 6; 
                else if (deg >= 157.5 || deg < -157.5) frameIndex = 3;
                else if (deg >= -157.5 && deg < -112.5) frameIndex = 0;
                else if (deg >= -112.5 && deg < -67.5) frameIndex = 1;
                else if (deg >= -67.5 && deg < -22.5) frameIndex = 2; 
                turret.setFrame(frameIndex);
                turret.rotation = 0; 
            } else {
                turret.setFrame(7); 
            }
        }
    });

    boomerangGlobalAngle += CONFIG.BOOMERANG_SPEED;
    boomerangs.getChildren().forEach(b => {
        if (!b.active) return;
        let currentAngle = boomerangGlobalAngle + b.phaseOffset;
        let radius = b.orbitRadius || CONFIG.BOOMERANG_RADIUS;
        b.x = player.x + Math.cos(currentAngle) * radius;
        b.y = player.y + Math.sin(currentAngle) * radius;
        b.rotation += 0.4; 
        if (b.shadowSprite) {
            b.shadowSprite.setPosition(b.x, b.y + 30);
            b.shadowSprite.setRotation(b.rotation);
        }
    });
}

function spawnZombieWave(scene) {
    if (gameOver) return;
    const progress = (60 - gameTime) / 60; 
    let count = Phaser.Math.Between(2, 10);
    let nextDelay = 1000 - (progress * 600); 
    const cam = scene.cameras.main;
    const padding = 50; 
    const view = cam.worldView;
    let centerX, centerY;
    const side = Phaser.Math.Between(0, 3);
    if (side === 0) { centerX = Phaser.Math.Between(view.x, view.right); centerY = view.y - padding; } 
    else if (side === 1) { centerX = Phaser.Math.Between(view.x, view.right); centerY = view.bottom + padding; } 
    else if (side === 2) { centerX = view.x - padding; centerY = Phaser.Math.Between(view.y, view.bottom); } 
    else { centerX = view.right + padding; centerY = Phaser.Math.Between(view.y, view.bottom); }

    for(let i=0; i<count; i++) {
        const offsetX = Phaser.Math.Between(-80, 80);
        const offsetY = Phaser.Math.Between(-80, 80);
        createOneEnemy(scene, centerX + offsetX, centerY + offsetY);
    }
    setActionLog(`Spawn Wave (${count})`);
    scene.time.delayedCall(nextDelay, () => spawnZombieWave(scene));
}

function createOneEnemy(scene, x, y) {
    const enemy = enemies.create(x, y, 'zombie_sheet');
    if(enemy) {
        const elapsed = 60 - gameTime;
        enemy.speed = CONFIG.SPEED_ZOMBIE_BASE + elapsed;
        enemy.hp = CONFIG.HP_ZOMBIE_BASE + Math.floor(elapsed * 1.2);
        enemy.setCircle(55, 9, 9); 
        enemy.setCollideWorldBounds(false); 
        enemy.setDepth(5);
        enemy.lastBoomerangHit = 0;
        enemy.stunUntil = 0; 
        enemy.setScale(0.4);
        enemy.isDying = false; 
        enemy.shadow = scene.add.sprite(x, y, 'shadowTex');
        enemy.shadow.setDepth(2);
        enemy.shadow.setScale(1.2, 0.4); 
        enemy.shadow.alpha = 0.4;
    }
}

function addTurret(scene, specificType = null) {
    const slotIndex = turretSlots.findIndex(s => !s.occupied);
    if (slotIndex === -1) return; 
    const slot = turretSlots[slotIndex];
    slot.occupied = true;
    let type = specificType;
    if (!type) {
        if (activeTurrets.length === 0) type = 'GUN';
        else {
            const rand = Math.random();
            if (rand < 0.33) type = 'GUN';
            else if (rand < 0.66) type = 'BOOMERANG';
            else type = 'CANNON';
        }
    }
    let textureKey;
    if (type === 'GUN') textureKey = 'gun8dir'; 
    else if (type === 'BOOMERANG') textureKey = 'boomerang8dir';
    else if (type === 'CANNON') textureKey = 'cannon8dir';
    
    const tSprite = scene.add.sprite(player.x, player.y, textureKey);
    tSprite.setDepth(11);
    if (type === 'GUN') { tSprite.setScale(0.5 * CONFIG.PLAYER_SCALE); }
    else if (type === 'CANNON') { tSprite.setScale(0.5 * CONFIG.PLAYER_SCALE); }
    else if (type === 'BOOMERANG') { tSprite.setScale(0.5 * CONFIG.PLAYER_SCALE); }
    else { tSprite.setScale(1.0); }
    let turretData = { type: type, sprite: tSprite, offsetX: slot.x, offsetY: slot.y, hasTarget: false, targetEntity: null, targetAngle: 0, lastFired: 0 };
    activeTurrets.push(turretData);
    if (type === 'BOOMERANG') spawnBoomerangProjectiles(scene);
    setActionLog("Installed " + type);
}

function spawnBoomerangProjectiles(scene) {
    let baseOffset = Math.random() * Math.PI * 2;
    const radiusMultipliers = [0.7, 1.0, 1.3];
    for(let i=0; i<3; i++) {
        let b = boomerangs.create(player.x, player.y, 'boomerangProjectile');
        b.setDepth(20); b.setCircle(45); 
        b.phaseOffset = baseOffset + (i * (Math.PI * 2 / 3));
        b.orbitRadius = CONFIG.BOOMERANG_RADIUS * radiusMultipliers[i]; 
        b.setScale(1.2); 
        let shadow = scene.add.sprite(0, 0, 'boomerangShadowTex');
        shadow.setDepth(8); shadow.setScale(1.2); shadow.setAlpha(0.5);
        b.shadowSprite = shadow;
    }
}

function fireTurrets() {
    if (gameOver) return;
    const now = game.loop.now;
    activeTurrets.forEach(tInfo => {
        if (tInfo.type === 'GUN' && tInfo.hasTarget) {
            const b = bullets.get(tInfo.sprite.x, tInfo.sprite.y);
            if (b) {
                b.setActive(true).setVisible(true);
                b.body.enable = true;
                b.setDepth(20);
                b.rotation = tInfo.targetAngle; 
                this.physics.velocityFromRotation(tInfo.targetAngle, CONFIG.BULLET_SPEED, b.body.velocity);
                b.setScale(0.25);
                b.body.updateFromGameObject();
                this.time.delayedCall(1500, () => { if(b.active) b.setActive(false).setVisible(false).body.enable = false; });
            }
        }
        else if (tInfo.type === 'CANNON' && tInfo.hasTarget) {
            if (now - tInfo.lastFired > 1500) {
                tInfo.lastFired = now;
                fireCannonBall(tInfo);
            }
        }
    });
}

function fireCannonBall(tInfo) {
    if (!tInfo.targetEntity || !tInfo.targetEntity.active) return;
    const scene = tInfo.sprite.scene;
    const ball = scene.add.sprite(tInfo.sprite.x, tInfo.sprite.y, 'cannonBallTex');
    ball.setDepth(25); ball.setScale(0.5); 
    scene.tweens.add({ targets: ball, angle: 720, duration: 750 }); 
    const target = tInfo.targetEntity;
    const tx = target.x; const ty = target.y;
    const dist = Phaser.Math.Distance.Between(ball.x, ball.y, tx, ty);
    const duration = Phaser.Math.Clamp(dist * 2, 500, 750); 
    const emitter = scene.add.particles(0, 0, 'trailTex', {
        speed: 0, lifespan: 300, scale: { start: 3.0, end: 0 }, alpha: { start: 0.8, end: 0 },
        quantity: 2, frequency: 20, blendMode: 'ADD', tint: COLORS.TRAIL_COLOR 
    });
    emitter.startFollow(ball); emitter.setDepth(24);
    scene.tweens.add({
        targets: ball, x: tx, y: ty, duration: duration, ease: 'Linear',
        onComplete: () => {
            emitter.stop(); scene.time.delayedCall(500, () => emitter.destroy());
            explodeCannonBall(scene, tx, ty); ball.destroy();
        }
    });
    scene.tweens.add({ targets: ball, scaleX: 1.2, scaleY: 1.2, duration: duration / 2, yoyo: true, ease: 'Sine.easeOut' });
}

function explodeCannonBall(scene, x, y) {
    const explosion = scene.add.sprite(x, y, 'explosionAnim');
    explosion.setDepth(30); explosion.setScale(2.5); explosion.play('explode');
    explosion.once('animationcomplete', () => { explosion.destroy(); });
    if (isDebugMode) {
        const debugCircle = scene.add.circle(x, y, CONFIG.CANNON_AOE_RADIUS);
        debugCircle.setStrokeStyle(2, 0x00FF00); debugCircle.setDepth(1001);
        scene.tweens.add({ targets: debugCircle, alpha: 0, duration: 1000, onComplete: () => debugCircle.destroy() });
    }
    enemies.getChildren().forEach(enemy => {
        if (!enemy.active) return;
        const dist = Phaser.Math.Distance.Between(x, y, enemy.x, enemy.y);
        if (dist <= CONFIG.CANNON_AOE_RADIUS) {
            enemy.hp -= CONFIG.DAMAGE_CANNON;
            enemy.setTintFill(0xff0000); 
            scene.time.delayedCall(100, () => { if(enemy.active) enemy.clearTint(); });
            const angle = Phaser.Math.Angle.Between(x, y, enemy.x, enemy.y);
            scene.physics.velocityFromRotation(angle, CONFIG.CANNON_KNOCKBACK, enemy.body.velocity);
            enemy.stunUntil = scene.time.now + CONFIG.CANNON_STUN_DURATION;
            if (enemy.hp <= 0) killEnemy(enemy);
        }
    });
}

function handlePlayerMovement(scene, time) {
    if (shipDestroyedSequence) { try { player.setVelocity(0); } catch (e) {} return; }
    player.setVelocity(0);
    let vx = 0, vy = 0;
    let keys = scene.input.keyboard.addKeys('W,A,S,D');
    if (cursors.left.isDown || keys.A.isDown) vx = -1; else if (cursors.right.isDown || keys.D.isDown) vx = 1;
    if (cursors.up.isDown || keys.W.isDown) vy = -1; else if (cursors.down.isDown || keys.S.isDown) vy = 1;
    if (isTouching) {
        let dx = scene.input.activePointer.x - touchStartPoint.x;
        let dy = scene.input.activePointer.y - touchStartPoint.y;
        if (Math.abs(dx) > 10 || Math.abs(dy) > 10) {
            let angle = Math.atan2(dy, dx);
            vx = Math.cos(angle); vy = Math.sin(angle);
        }
    }
    if (vx !== 0 || vy !== 0) {
        const vec = new Phaser.Math.Vector2(vx, vy).normalize().scale(CONFIG.SPEED_PLAYER);
        player.setVelocity(vec.x, vec.y);
    }
}

function setupVirtualJoystick(scene) {
    scene.input.on('pointerdown', (pointer) => { touchStartPoint.x = pointer.x; touchStartPoint.y = pointer.y; isTouching = true; });
    scene.input.on('pointerup', () => { isTouching = false; });
}

function hitEnemy(bullet, enemy) {
    if (!bullet.active || !enemy.active) return;
    bullet.setActive(false).setVisible(false).body.enable = false;
    applyDamageToEnemy(enemy, damagePerShot);
}

function hitEnemyByBoomerang(boomerang, enemy) {
    if (!enemy.active) return;
    const now = game.loop.now;
    if (now - enemy.lastBoomerangHit > 500) {
        enemy.lastBoomerangHit = now;
        applyDamageToEnemy(enemy, CONFIG.DAMAGE_BOOMERANG); 
    }
}

function applyDamageToEnemy(enemy, dmg) {
    if (enemy.isDying) return; 
    enemy.hp -= dmg;
    enemy.setTintFill(0xffffff);
    enemy.scene.time.delayedCall(50, () => { if(enemy.active) enemy.clearTint(); });
    enemy.stunUntil = enemy.scene.time.now + CONFIG.HIT_STUN_DURATION;
    if (enemy.hp <= 0) killEnemy(enemy);
}

function flashHit(sprite, scene) {
    if (!sprite || !sprite.active) return;
    if (sprite.__tintTimer) { try { sprite.__tintTimer.remove(false); } catch (e) {} sprite.__tintTimer = null; }
    try { sprite.setTintFill(0xffffff); } catch (e) {}
    sprite.__tintTimer = scene.time.delayedCall(100, () => {
        if (!sprite || !sprite.active) return;
        try { sprite.clearTint(); } catch (e) {}
        sprite.__tintTimer = null;
    });
}

function flashShipAndWheels(scene) {
    flashHit(player, scene);
    flashHit(wheelLeft, scene);
    flashHit(wheelRight, scene);
}

function handleTrample(obj, enemy) {
    if (gameOver || !enemy.active || enemy.isDying) return;
    if (!isDebugMode) {
        hp -= CONFIG.HP_TRAMPLE_COST;
        showFloatText(this, player.x, player.y - 60, `-${CONFIG.HP_TRAMPLE_COST}`, '#ff0000');
        flashShipAndWheels(this);
    }
    this.cameras.main.shake(100, 0.005);
    killEnemy(enemy);
    if (!isDebugMode && hp <= 0) startShipDestroyedSequence(this);
}

function killEnemy(enemy) {
    if (!enemy.active || enemy.isDying) return; 
    enemy.isDying = true; enemy.body.enable = false; enemy.setVelocity(0); 
    if (enemy.shadow) enemy.shadow.destroy();
    explosionEmitter.emitParticleAt(enemy.x, enemy.y, 6);
    comboCount++;
    if (comboTimerEvent) comboTimerEvent.remove(); 
    comboTimerEvent = enemy.scene.time.delayedCall(CONFIG.COMBO_TIMEOUT, resetCombo, [], enemy.scene);
    updateComboUI(); 
    let killScore = 10 + (comboCount * 2);
    score += killScore;
    enemy.setTexture('zombie_death');
    if (enemy.anims.currentAnim && enemy.anims.currentAnim.key === 'z_left') { enemy.setFlipX(true); } else { enemy.setFlipX(false); }
    const animKey = Math.random() < 0.5 ? 'death_1' : 'death_2';
    enemy.play(animKey);

    const chance = Phaser.Math.Between(0, 100);
    const elapsed = 60 - gameTime; 
    const allowedLetters = Math.floor(elapsed / 4) + 1;
    const allowedHearts = Math.floor(elapsed / 6) + 1;
    let allowedPowerUps = 0;
    if (elapsed < 30) allowedPowerUps = Math.floor(elapsed / 6) + 1;
    else if (elapsed < 50) allowedPowerUps = 5;
    else allowedPowerUps = 8;
    let allowedTurretsTotal = 1; 
    if (elapsed < 15) allowedTurretsTotal = 3;      
    else if (elapsed < 30) allowedTurretsTotal = 5; 
    else allowedTurretsTotal = 6;                   
    if (chance < 8) {
        if (droppedCounts.heart < CONFIG.LIMIT_HEART && droppedCounts.heart < allowedHearts) dropItem(enemy.scene, enemy.x, enemy.y, 'HEART');
    } else if (chance < 25) {
        let turretsOnGround = pickups.getChildren().filter(p => p.active && p.dropType === 'TURRET').length;
        let currentTotal = activeTurrets.length + turretsOnGround;
        if (currentTotal < allowedTurretsTotal) dropItem(enemy.scene, enemy.x, enemy.y, 'TURRET');
        else if (collectedIndices.length < allowedLetters) dropItem(enemy.scene, enemy.x, enemy.y, 'LETTER');
    } else if (chance < 40) {
        if (droppedCounts.powerup < CONFIG.LIMIT_POWERUP && droppedCounts.powerup < allowedPowerUps) dropItem(enemy.scene, enemy.x, enemy.y, 'POWERUP');
    } else {
        if (collectedIndices.length < allowedLetters) dropItem(enemy.scene, enemy.x, enemy.y, 'LETTER');
    }
    enemy.once('animationcomplete', () => {
        enemy.scene.tweens.add({ targets: enemy, alpha: 0, duration: 120, yoyo: true, repeat: 1, delay: 200, onComplete: () => { enemy.destroy(); } });
    });
}

function resetCombo() { if(comboCount > 0) { comboText.setText(""); comboCount = 0; } }

function updateComboUI() {
    if (comboCount > 1) {
        comboText.setText(`COMBO x${comboCount}`); comboText.setVisible(true); comboText.setScale(1.5);
        if(comboScaleTween) comboScaleTween.stop();
        comboScaleTween = game.scene.scenes[0].tweens.add({ targets: comboText, scaleX: 1, scaleY: 1, duration: 200, ease: 'Back.out' });
    } else { comboText.setVisible(false); }
}

function dropItem(scene, x, y, type) {
    setActionLog("Dropped " + type);
    if (type === 'LETTER') {
        let needed = [];
        targetLetters.forEach((l, i) => { if(!collectedIndices.includes(i)) needed.push({l, i}); });
        if (needed.length === 0) type = 'HEART'; 
    }
    if (type === 'POWERUP') droppedCounts.powerup++;
    if (type === 'HEART') droppedCounts.heart++;
    
    let sprite;
    if (type === 'TURRET') {
        const rand = Math.random();
        let specificType = 'GUN';
        if (rand < 0.33) specificType = 'GUN';
        else if (rand < 0.66) specificType = 'BOOMERANG';
        else specificType = 'CANNON';
        let tex;
        if (specificType === 'GUN') tex = 'gun8dir';
        else if (specificType === 'CANNON') tex = 'cannon8dir';
        else tex = 'boomerang8dir';
        sprite = pickups.create(x, y, tex);
        sprite.play('spin_' + specificType.toLowerCase()); 
        sprite.setScale(0.6); sprite.specificType = specificType; 
        sprite.setDrag(1000); sprite.setBounce(0.5); sprite.setCircle(40); 
    } else {
        if (type === 'HEART') {
            sprite = pickups.create(x, y, 'heartSheet', 0);
            sprite.play('spin_heart');
            sprite.setScale(0.7); sprite.setCircle(40);
            if (sprite.body) { sprite.body.setAllowGravity(false); sprite.body.setImmovable(true); sprite.body.setSize(90, 90, true); }
            try { scene.physics.add.collider(enemies, sprite); } catch (e) {}
        }
        else if (type === 'POWERUP') {
            sprite = pickups.create(x, y, 'powerupSheet', 0);
            sprite.play('spin_powerup');
            sprite.setScale(0.8); sprite.setCircle(40);
            if (sprite.body) { sprite.body.setAllowGravity(false); sprite.body.setImmovable(true); sprite.body.setSize(90, 90, true); }
            try { scene.physics.add.collider(enemies, sprite); } catch (e) {}
        }
        else if (type === 'LETTER') {
            let needed = [];
            targetLetters.forEach((l, i) => { if (!collectedIndices.includes(i) && !droppedLetterIndices.includes(i)) needed.push({ l, i }); });
            if (needed.length === 0) return; 
            let pick = Phaser.Utils.Array.GetRandom(needed);
            const letterSpr = scene.add.sprite(x, y, 'hnyLetters', pick.i).setOrigin(0.5);
            letterSpr.setScale(0.42);
            scene.physics.add.existing(letterSpr);
            if (letterSpr.body) { letterSpr.body.setAllowGravity(false); letterSpr.body.setImmovable(true); letterSpr.body.setSize(90, 90, true); }
            letterSpr.canMagnet = false;
            pickups.add(letterSpr);
            letterSpr.pickupReady = false;
            scene.time.delayedCall(2000, () => { if (letterSpr.active) autoCollectLetterToHUD(scene, letterSpr); });
            scene.tweens.add({ targets: letterSpr, y: y - 8, duration: 650, yoyo: true, repeat: -1, ease: 'Sine.easeInOut' });
            try { scene.physics.add.collider(enemies, letterSpr); } catch (e) {}
            sprite = letterSpr; sprite.letterIndex = pick.i;
            if (!droppedLetterIndices.includes(pick.i)) droppedLetterIndices.push(pick.i);
        }
        scene.tweens.add({ targets: sprite, y: y - 10, duration: 500, yoyo: true, repeat: -1 });
    }
    if (type === 'TURRET' || type === 'POWERUP' || type === 'HEART') {
        sprite.shadow = scene.add.sprite(x, y, 'shadowTex');
        sprite.shadow.setDepth(1); sprite.shadow.setScale(1.9); sprite.shadow.alpha = 0.4;
    }
    sprite.dropType = type;
    sprite.isMagneting = false; sprite.canMagnet = false;
    scene.time.delayedCall(1000, () => { if(sprite.active) sprite.canMagnet = true; });
    sprite.setDepth(6);
}

function autoCollectLetterToHUD(scene, drop) {
    if (!drop || !drop.active) return;
    if (typeof drop.letterIndex !== 'number') return;
    if (!hnyHudSprites || !hnyHudSprites.list || !hnyHudSprites.list[drop.letterIndex]) {
        if (!collectedIndices.includes(drop.letterIndex)) { collectedIndices.push(drop.letterIndex); updateLetterUI(); }
        try { drop.destroy(); } catch (e) {}
        return;
    }
    if (collectedIndices.includes(drop.letterIndex)) { try { drop.destroy(); } catch (e) {} return; }
    const cam = scene.cameras.main;
    const hudSpr = hnyHudSprites.list[drop.letterIndex];
    const tx = hnyHudSprites.x + hudSpr.x;
    const ty = hnyHudSprites.y + hudSpr.y;
    const sx = drop.x - cam.scrollX;
    const sy = drop.y - cam.scrollY;
    const fly = scene.add.sprite(sx, sy, 'hnyLetters', drop.letterIndex).setOrigin(0.5).setScale(drop.scaleX || 0.42).setScrollFactor(0).setDepth(2000);
    try { drop.destroy(); } catch (e) {}
    scene.tweens.add({
        targets: fly, x: tx, y: ty, scaleX: hudSpr.scaleX || 0.42, scaleY: hudSpr.scaleY || 0.42, duration: 260, ease: 'Quad.easeInOut',
        onComplete: () => {
            try { fly.destroy(); } catch (e) {}
            collectedIndices.push(drop.letterIndex); updateLetterUI();
            try {
                const spr = hnyHudSprites.list[drop.letterIndex];
                const baseScale = spr.scaleX || 0.42;
                scene.tweens.add({ targets: spr, scaleX: baseScale * 1.18, scaleY: baseScale * 1.18, duration: 90, yoyo: true, ease: 'Quad.easeOut' });
                spr.setBlendMode(Phaser.BlendModes.ADD); spr.setTintFill(0xffffaa);
                scene.time.delayedCall(120, () => { if (!spr || !spr.active) return; spr.clearTint(); spr.setBlendMode(Phaser.BlendModes.NORMAL); });
            } catch (e) {}
        }
    });
}

function showHPSprite(scene) {
    if (!player || !player.active) return;
    try { if (window._activeHPText && window._activeHPText.active) { window._activeHPText.destroy(); } } catch (e) {}
    const img = scene.add.image(player.x, player.y - 80, 'textHP').setDepth(1000).setScale(0.5);
    window._activeHPText = img;
    const floatObj = { v: 0 };
    const follow = () => { if (!img.active || !player || !player.active) { scene.events.off('update', follow); return; } img.x = player.x; img.y = player.y - 80 + floatObj.v; };
    scene.events.on('update', follow);
    scene.tweens.add({ targets: floatObj, v: -40, duration: 1000, ease: 'Cubic.easeOut' });
    scene.tweens.add({ targets: img, alpha: 0, duration: 250, delay: 1000, ease: 'Linear', onComplete: () => { try { scene.events.off('update', follow); } catch (e) {} try { if (window._activeHPText === img) window._activeHPText = null; } catch (e) {} img.destroy(); } });
}

function showPowerupSprite(scene) {
    if (!player || !player.active) return;
    try { if (window._activePowerupText && window._activePowerupText.active) { window._activePowerupText.destroy(); } } catch (e) {}
    const img = scene.add.image(player.x, player.y - 80, 'textPowerup').setDepth(1000).setScale(0.5);
    window._activePowerupText = img;
    const floatObj = { v: 0 };
    const follow = () => { if (!img.active || !player || !player.active) { scene.events.off('update', follow); return; } img.x = player.x; img.y = player.y - 80 + floatObj.v; };
    scene.events.on('update', follow);
    scene.tweens.add({ targets: floatObj, v: -40, duration: 1000, ease: 'Cubic.easeOut' });
    scene.tweens.add({ targets: img, alpha: 0, duration: 250, delay: 1000, ease: 'Linear', onComplete: () => { try { scene.events.off('update', follow); } catch (e) {} try { if (window._activePowerupText === img) window._activePowerupText = null; } catch (e) {} img.destroy(); } });
}

function flashPowerupGreen(scene) {
    try {
        const targets = [];
        if (player && player.active) targets.push(player);
        if (wheelLeft && wheelLeft.active) targets.push(wheelLeft);
        if (wheelRight && wheelRight.active) targets.push(wheelRight);
        if (Array.isArray(activeTurrets)) { activeTurrets.forEach(t => { if (t && t.active) targets.push(t); }); }
        if (Array.isArray(turretSlots)) { turretSlots.forEach(s => { if (s && s.turret && s.turret.active) targets.push(s.turret); }); }
        if (targets.length === 0) return;
        targets.forEach(s => { s.setTintFill(0x000fff0); });
        scene.time.delayedCall(60, () => { targets.forEach(s => { if (s && s.active) s.clearTint(); }); });
    } catch (e) {}
}

function collectPickup(player, drop) {
    const scene = drop.scene;
    if (drop.dropType === 'LETTER') return;
    setActionLog("Get " + drop.dropType);
    if (drop.dropType === 'HEART') {
        hp = Math.min(hp + 20, maxHp); showHPSprite(scene); flashPowerupGreen(scene);
    } else if (drop.dropType === 'TURRET') {
        if (activeTurrets.length < 6) {
            addTurret(scene, drop.specificType); 
            let msg = drop.specificType; if(msg === 'BOOMERANG') msg = 'SAW!';
            showFloatText(scene, player.x, player.y, msg + "!", COLORS.TURRET);
        } else { score += 200; showFloatText(scene, player.x, player.y, "+200", COLORS.TURRET); }
    } else if (drop.dropType === 'POWERUP') {
        damagePerShot += 1; showPowerupSprite(scene); score += 100; flashPowerupGreen(scene);
    }
    else if (drop.dropType === 'LETTER') {
        if (!collectedIndices.includes(drop.letterIndex)) {
            try {
                if (hnyHudSprites && hnyHudSprites.list && hnyHudSprites.list[drop.letterIndex]) {
                    const hudSpr = hnyHudSprites.list[drop.letterIndex];
                    const fly = scene.add.sprite(drop.x, drop.y, 'hnyLetters', drop.letterIndex).setOrigin(0.5).setScale(drop.scaleX || 0.42).setDepth(2000);
                    const tx = hnyHudSprites.x + hudSpr.x;
                    const ty = hnyHudSprites.y + hudSpr.y;
                    scene.tweens.add({
                        targets: fly, x: tx, y: ty, scaleX: hudSpr.scaleX || 0.42, scaleY: hudSpr.scaleY || 0.42, duration: 260, ease: 'Quad.easeInOut',
                        onComplete: () => {
                            try { fly.destroy(); } catch (e) {}
                            collectedIndices.push(drop.letterIndex); updateLetterUI();
                            try {
                                const spr = hnyHudSprites.list[drop.letterIndex];
                                const baseScale = spr.scaleX || 0.42;
                                scene.tweens.add({ targets: spr, scaleX: baseScale * 1.18, scaleY: baseScale * 1.18, duration: 90, yoyo: true, ease: 'Quad.easeOut' });
                                spr.setBlendMode(Phaser.BlendModes.ADD); spr.setTintFill(0xffffaa);
                                scene.time.delayedCall(120, () => { if (!spr || !spr.active) return; spr.clearTint(); spr.setBlendMode(Phaser.BlendModes.NORMAL); });
                            } catch (e) {}
                        }
                    });
                } else { collectedIndices.push(drop.letterIndex); updateLetterUI(); }
            } catch (e) { collectedIndices.push(drop.letterIndex); updateLetterUI(); }
            showFloatText(scene, player.x, player.y, drop.text, COLORS.LETTER);
            score += 500;
        }
    }
    if (drop.shadow) drop.shadow.destroy();
    drop.destroy();
}

function showFloatText(scene, x, y, msg, color) {
    const txt = scene.add.text(x, y - 40, msg, { fontSize: '18px', color: (typeof color === 'string' ? color : '#' + color.toString(16)), fontStyle: 'bold', stroke: '#fff', strokeThickness: 3 }).setOrigin(0.5).setDepth(100);
    scene.tweens.add({ targets: txt, y: y - 100, alpha: 0, duration: 800, onComplete: () => txt.destroy() });
}

function generateTextures(scene) {
    const g = scene.make.graphics({x:0, y:0, add:false});
    g.clear(); g.fillStyle(0x000000, 1); g.fillCircle(16, 16, 14); g.generateTexture('shadowTex', 32, 32);
    g.clear(); g.fillStyle(0xFFFFFF, 1); g.fillRect(0, 0, 16, 16); g.generateTexture('trailSquare', 16, 16);
    g.clear(); g.fillStyle(COLORS.TURRET, 1); g.fillTriangle(24, 12, 0, 0, 0, 24); g.lineStyle(1, 0x000000); g.strokeTriangle(24, 12, 0, 0, 0, 24); g.generateTexture('turretTex', 24, 24);
    g.clear(); g.fillStyle(COLORS.BOOMERANG_RING, 1); g.fillCircle(12, 12, 10); g.lineStyle(2, 0x000000); g.strokeCircle(12, 12, 10); g.generateTexture('boomerangIconTex', 24, 24);
    g.clear(); g.lineStyle(4, COLORS.BOOMERANG_RING); g.strokeCircle(20, 20, 16); g.generateTexture('boomerangProjTex', 40, 40);
    g.clear(); g.fillStyle(COLORS.CANNON_ICON, 1); g.fillRect(0,0,24,24); g.lineStyle(2, 0x000000); g.strokeRect(0,0,24,24); g.generateTexture('cannonIconTex', 24, 24);
    g.clear(); g.fillStyle(COLORS.CANNON_BALL, 1); g.fillCircle(8,8,8); g.generateTexture('cannonBallTex', 16, 16);
    g.clear(); g.fillStyle(COLORS.TRAIL_SMOKE, 1); g.fillCircle(5,5,5); g.generateTexture('trailTex', 10, 10);
    g.clear(); g.fillStyle(COLORS.TURRET, 1); g.lineStyle(2,0); g.fillRect(0,0,20,20); g.strokeRect(0,0,20,20); g.generateTexture('turretDropTex', 20, 20);
    g.clear(); g.fillStyle(COLORS.ARROW, 1); g.fillTriangle(40, 20, 0, 40, 0, 0); g.generateTexture('arrowTex', 40, 40);
    g.clear(); g.fillStyle(COLORS.BULLET, 1); g.fillCircle(4,4,4); g.generateTexture('bulletTex', 8, 8);
    // Heart texture for HP icon
    g.clear(); g.fillStyle(COLORS.HEART, 1); g.fillCircle(8,8,8); g.generateTexture('heartTex', 16, 16);
    g.clear(); g.fillStyle(COLORS.POWERUP_BG, 1); g.fillRect(0,0,24,24); g.lineStyle(2, 0xffffff); g.strokeRect(0,0,24,24); g.fillStyle(0xffffff, 1); g.fillRect(4, 4, 16, 4); g.fillRect(4, 4, 4, 16); g.fillRect(16, 4, 4, 8); g.fillRect(4, 12, 16, 4); g.generateTexture('powerupTex', 24, 24);
    g.clear(); g.fillStyle(COLORS.HAPPY, 1); g.fillCircle(12, 12, 12); g.fillStyle(0x000000, 1); g.fillCircle(8, 10, 2); g.fillCircle(16, 10, 2); g.beginPath(); g.lineStyle(2, 0x000000); g.arc(12, 12, 6, 0.1*Math.PI, 0.9*Math.PI, false); g.strokePath(); g.generateTexture('happyTex', 24, 24);
    
    // MODIFIED: Generate Clock Texture
    g.clear();
    g.fillStyle(0x555555, 1); // rim
    g.fillCircle(16, 16, 16);
    g.fillStyle(0xFFFFFF, 1); // face
    g.fillCircle(16, 16, 13);
    g.fillStyle(0xCC0000, 1); // hands
    g.fillRect(15, 6, 2, 10); // vertical hand
    g.fillRect(15, 15, 8, 2); // horizontal hand
    g.generateTexture('clockTex', 32, 32);

    const zG = scene.make.graphics({x:0, y:0, add:false});
    const size = 128;
    for(let row=0; row<4; row++) {
        for(let col=0; col<4; col++) {
            const cx = col * size + size/2;
            const cy = row * size + size/2;
            zG.fillStyle(0x448844, 1);
            zG.fillRect(col*size + 10, row*size + 10, size-20, size-20);
            zG.fillStyle(0xFFFFFF, 1);
            if(col === 0) { zG.fillTriangle(cx-10, cy-10, cx+10, cy-10, cx, cy+20); } 
            else if(col === 1) { zG.fillTriangle(cx-10, cy+10, cx+10, cy+10, cx, cy-20); } 
            else if(col === 2) { zG.fillTriangle(cx+10, cy-10, cx+10, cy+10, cx-20, cy); } 
            else { zG.fillTriangle(cx-10, cy-10, cx-10, cy+10, cx+20, cy); }
        }
    }
    zG.generateTexture('zombie_sheet', 512, 512);
}

function createUI(scene) {
    // MODIFIED: UI Layout Update (Pixel Font, Icons)

    // 1. Background Boxes (New)
    hudBg = scene.add.graphics();
    hudBg.setScrollFactor(0);
    hudBg.setDepth(160); // 层级，在文字下面(文字是200)
    
    // 设置颜色和透明度
    // 0x000000 是黑色
    // 0.5 是透明度 (0.0 完全透明 ~ 1.0 不透明)
    hudBg.fillStyle(0x000000, 0.5); 
    
    // === HP 的背景框 (左上角) ===
    // 参数顺序: (x坐标, y坐标, 宽度, 高度, 圆角半径)
    // 目前尺寸: 宽130, 高50
    hudBg.fillRoundedRect(-50, -115, 130, 45, 8);

    // === Score 的背景框 (右上角) ===
    // x坐标计算: 屏幕总宽(540) - 260 = 280
    // 目前尺寸: 宽250, 高50
    hudBg.fillRoundedRect(gameConfig.scale.width - 230, -115, 290, 45, 8);


    // 1. HP Icon + Text (Top Left)
    const uiY_Row1 = -90;
    
    hpIcon = scene.add.sprite(-30, uiY_Row1, 'heartSheet', 3).setScrollFactor(0).setDepth(200).setScale(0.3);
    hpText = scene.add.text(-10, uiY_Row1, 'x100', { 
        fontSize: '20px', 
        fontFamily: '"Press Start 2P"',
        fill: '#ff0000' 
    }).setOrigin(0, 0.5).setScrollFactor(0).setDepth(200);

    // 2. Score (Top Right)
    scoreText = scene.add.text(gameConfig.scale.width +50, uiY_Row1, 'SCORE: 0', { 
        fontSize: '20px', 
        fontFamily: '"Press Start 2P"', 
        fill: '#FFFFFF' 
    }).setOrigin(1, 0.5).setScrollFactor(0).setDepth(200);

    // 3. Clock + Time (Bottom Center - Row 2)
    const uiY_Row2 = -20;
    const centerX = gameConfig.scale.width / 2;
    
    // Icon (Left of text)
    // Text (Right of icon)
    // Countdown digits (spritesheet 0-9)
    const digitScale = 0.6;
    const digitW = 110 * digitScale;
    const digitGap = -10;
    // Keep the original timeText (hidden) for compatibility, but we no longer use it for rendering
    timeText = scene.add.text(centerX - 10, uiY_Row2 + 5, '', { 
        fontSize: '1px', 
        fontFamily: '"Press Start 2P"', 
        fill: '#000000'
    }).setOrigin(0, 0.5).setScrollFactor(0).setDepth(200).setVisible(false);

    timeDigitTens = scene.add.sprite(centerX - 70, uiY_Row2 + 10, 'countdownNumbers', 6)
        .setOrigin(0, 0.5).setScrollFactor(0).setDepth(200).setScale(digitScale);

    timeDigitOnes = scene.add.sprite(centerX - 70 + digitW + digitGap, uiY_Row2 + 10, 'countdownNumbers', 0)
        .setOrigin(0, 0.5).setScrollFactor(0).setDepth(200).setScale(digitScale);
// Bottom Letter HUD
    letterText = null;
    hnyHudSprites = scene.add.container(scene.scale.width / 2, scene.scale.height - 120).setScrollFactor(0).setDepth(999);
    
    // === UI Intro Animation Setup (HUD hidden until game starts) ===
    uiIntroTargets = {
        hudBgY: hudBg ? hudBg.y : 0,
        hpIconY: hpIcon ? hpIcon.y : 0,
        hpTextY: hpText ? hpText.y : 0,
        scoreTextY: scoreText ? scoreText.y : 0,
        timeTextY: timeText ? timeText.y : 0,
        timeDigitTensY: timeDigitTens ? timeDigitTens.y : 0,
        timeDigitOnesY: timeDigitOnes ? timeDigitOnes.y : 0,
        hnyHudY: hnyHudSprites ? hnyHudSprites.y : 0
    };

    const TOP_OFF = -220; // fly-in from above
    const BOTTOM_OFF = 260; // fly-in from below

    // Hide top HUD (HP / SCORE / TIMER) until game starts
    if (hudBg) { hudBg.y = uiIntroTargets.hudBgY + TOP_OFF; hudBg.setVisible(false); }
    if (hpIcon) { hpIcon.y = uiIntroTargets.hpIconY + TOP_OFF; hpIcon.setVisible(false); }
    if (hpText) { hpText.y = uiIntroTargets.hpTextY + TOP_OFF; hpText.setVisible(false); }
    if (scoreText) { scoreText.y = uiIntroTargets.scoreTextY + TOP_OFF; scoreText.setVisible(false); }
    if (timeText) { timeText.y = uiIntroTargets.timeTextY + TOP_OFF; timeText.setVisible(false); }
    if (timeDigitTens) { timeDigitTens.y = uiIntroTargets.timeDigitTensY + TOP_OFF; timeDigitTens.setVisible(false); }
    if (timeDigitOnes) { timeDigitOnes.y = uiIntroTargets.timeDigitOnesY + TOP_OFF; timeDigitOnes.setVisible(false); }

    // Hide bottom HNY HUD until game starts
    if (hnyHudSprites) { hnyHudSprites.y = uiIntroTargets.hnyHudY + BOTTOM_OFF; hnyHudSprites.setVisible(false); }
const hudScale = 0.42; 
    const total = targetLetters.length;
    const spacing = (110 * hudScale + 5) * 0.85;     
    const wordGap = spacing * 0.75;         
    const totalWidth = ((total - 1) * spacing) + (2 * wordGap);
    const startX = -(totalWidth) / 2;
    for (let i = 0; i < total; i++) {
        const extraGap = (i > 4 ? wordGap : 0) + (i > 7 ? wordGap : 0);
        const s = scene.add.sprite(startX + i * spacing + extraGap, 0, 'hnyLetters', i).setDepth(999);
        s.setScale(hudScale);
        s.setOrigin(0.5);        
        if (!collectedIndices.includes(i)) s.setTexture('questionMark');
        hnyHudSprites.add(s);
    }
    
    fpsText = scene.add.text(10, gameConfig.scale.height - 30, 'FPS: 60', { fontSize: '14px', fill: '#00aa00', fontStyle: 'bold', stroke: '#fff', strokeThickness: 2 }).setScrollFactor(0).setDepth(500);
    fpsText.setVisible(false); // Hide FPS as requested

    comboText = scene.add.text(20, 150, '', { fontSize: '36px', fill: '#FF4500', fontStyle: 'bold', stroke: '#fff', strokeThickness: 6 }).setScrollFactor(0).setDepth(200).setVisible(false);
    
    // REMOVED High Score Text from HUD
}


function runHUDIntro(scene) {
    if (!uiIntroTargets) return;

    const DUR = 220;
    const DELAY = 0; // delay handled by caller
    const EASE = 'Back.out';

    // Make visible before tween
    if (hudBg) hudBg.setVisible(true);
    if (hpIcon) hpIcon.setVisible(true);
    if (hpText) hpText.setVisible(true);
    if (scoreText) scoreText.setVisible(true);
    if (timeText) timeText.setVisible(true);
    if (timeDigitTens) timeDigitTens.setVisible(true);
    if (timeDigitOnes) timeDigitOnes.setVisible(true);
    if (hnyHudSprites) hnyHudSprites.setVisible(true);

    // Top HUD fly in from above
    if (hudBg) scene.tweens.add({ targets: hudBg, y: uiIntroTargets.hudBgY, duration: DUR, delay: DELAY, ease: EASE });
    if (hpIcon) scene.tweens.add({ targets: hpIcon, y: uiIntroTargets.hpIconY, duration: DUR, delay: DELAY, ease: EASE });
    if (hpText) scene.tweens.add({ targets: hpText, y: uiIntroTargets.hpTextY, duration: DUR, delay: DELAY, ease: EASE });
    if (scoreText) scene.tweens.add({ targets: scoreText, y: uiIntroTargets.scoreTextY, duration: DUR, delay: DELAY, ease: EASE });
    if (timeText) scene.tweens.add({ targets: timeText, y: uiIntroTargets.timeTextY, duration: DUR, delay: DELAY, ease: EASE });
    if (timeDigitTens) scene.tweens.add({ targets: timeDigitTens, y: uiIntroTargets.timeDigitTensY, duration: DUR, delay: DELAY, ease: EASE });
    if (timeDigitOnes) scene.tweens.add({ targets: timeDigitOnes, y: uiIntroTargets.timeDigitOnesY, duration: DUR, delay: DELAY, ease: EASE });

    // Bottom HNY fly in from below
    if (hnyHudSprites) scene.tweens.add({ targets: hnyHudSprites, y: uiIntroTargets.hnyHudY, duration: DUR, delay: DELAY, ease: EASE });
}


function updateTimer() {
    if (gameOver) return;
    gameTime--;
    // Update countdown digit sprites (always force-read from gameTime)
    const t = Math.max(0, Math.floor(gameTime));
    const tens = Math.floor(t / 10);
    const ones = t % 10;
    if (timeDigitTens) timeDigitTens.setFrame(Math.max(0, Math.min(9, tens)));
    if (timeDigitOnes) timeDigitOnes.setFrame(Math.max(0, Math.min(9, ones)));
    if (gameTime <= 0) doGameOver(this, true);
}

function getLetterString() {
    let display = "";
    for(let i=0; i<targetLetters.length; i++) {
        if (collectedIndices.includes(i)) display += targetLetters[i] + " "; else display += "_ ";
    }
    return display;
}

function updateLetterUI() {
    if (hnyHudSprites) {
        const kids = hnyHudSprites.list || [];
        for (let i = 0; i < kids.length; i++) {
            const spr = kids[i];
            if (!spr) continue;
            if (collectedIndices.includes(i)) {
                spr.setTexture('hnyLetters', i); spr.clearTint(); spr.setBlendMode(Phaser.BlendModes.NORMAL);
            } else {
                spr.setTexture('questionMark'); spr.clearTint(); spr.setBlendMode(Phaser.BlendModes.NORMAL);
            }
        }
    } else if (letterText) { letterText.setText(getLetterString()); }
}

function startShipDestroyedSequence(scene) {
    if (shipDestroyedSequence) return;
    shipDestroyedSequence = true;
    try { if (window._activePowerupText && window._activePowerupText.active) { window._activePowerupText.destroy(); } if (window._activeHPText && window._activeHPText.active) { window._activeHPText.destroy(); } window._activePowerupText = null; window._activeHPText = null; } catch (e) {}
    try { if (timerEvent) { timerEvent.remove(); } } catch (e) {}
    try { if (fireEvent) { fireEvent.remove(); } } catch (e) {}
    try { if (comboTimerEvent) { comboTimerEvent.remove(); } } catch (e) {}
    try { if (player && player.body) { player.setVelocity(0); player.body.enable = false; } } catch (e) {}
    const DURATION_MS = 2000;
    const INTERVAL_MS = 180;
    const startTime = scene.time.now;
    const spawnOne = () => {
        if (!scene || !scene.add) return;
        const baseX = player?.x ?? (CONFIG.WIDTH / 2);
        const baseY = player?.y ?? (CONFIG.HEIGHT / 2);
        const w = (player?.displayWidth || player?.width || 140);
        const h = (player?.displayHeight || player?.height || 140);
        const points = [ { x: 0.0,  y: 0.0 }, { x: 0.0,  y: -0.28 }, { x: 0.0,  y: 0.26 }, { x: -0.26, y: -0.02 }, { x: 0.26,  y: -0.02 }, { x: -0.34, y: -0.12 }, { x:  0.34, y: -0.12 }, { x: -0.40, y:  0.18 }, { x:  0.40, y:  0.18 }, { x:  0.00, y:  0.34 } ];
        const p = points[Phaser.Math.Between(0, points.length - 1)];
        const jitterX = Phaser.Math.Between(-Math.max(16, w * 0.08), Math.max(16, w * 0.08));
        const jitterY = Phaser.Math.Between(-Math.max(16, h * 0.08), Math.max(16, h * 0.08));
        const ox = p.x * w + jitterX;
        const oy = p.y * h + jitterY;
        const boom = scene.add.sprite(baseX + ox, baseY + oy, 'explosion8', 0);
        boom.setDepth(9999); boom.setScale(0.9 + Math.random() * 0.4); boom.play('explosion_play');
        boom.once('animationcomplete', () => { boom.destroy(); });
    };
    spawnOne();
    scene.time.delayedCall(90, spawnOne);
    const loop = scene.time.addEvent({
        delay: INTERVAL_MS, loop: true,
        callback: () => {
            const elapsed = scene.time.now - startTime;
            if (elapsed >= DURATION_MS) { loop.remove(); doGameOver(scene, false); return; }
            spawnOne(); if (Math.random() < 0.35) spawnOne();
        }
    });
}

function doGameOver(scene, win) {
    gameOver = true;
    try { scene.physics.pause(); } catch (e) {}
    try { if (timerEvent) { timerEvent.remove(); } } catch (e) {}
    try { if (fireEvent) { fireEvent.remove(); } } catch (e) {}
    try { if (comboTimerEvent) { comboTimerEvent.remove(); } } catch (e) {}
    const overlay = document.getElementById('game-over-ui');
    const goScore = document.getElementById('go-score');
    const goBest = document.getElementById('go-best');    const goLetters = document.getElementById('go-letters');
    const goTitle = document.getElementById('go-title');
    goScore.innerText = score;
    if (score > highScore) { saveHighScore(score); }
    goBest.innerText = highScore;
    try { renderHappyNewYearSpritesDOM(new Set(collectedIndices || [])); } catch (e) {}
    let letterStr = "";
    for(let i=0; i<targetLetters.length; i++) { if (collectedIndices.includes(i)) letterStr += targetLetters[i] + " "; else letterStr += "_ "; }
    goLetters.innerText = '';
    if (win) { goTitle.innerText = "HAPPY NEW YEAR!"; goTitle.style.color = "#FFD700"; } else { goTitle.innerText = "GAME OVER"; goTitle.style.color = "#FF0000"; }
    overlay.style.display = 'flex';
    try {
        window.LeaderboardAPI?.open?.({ score, nameInputId: 'player-name-input' });
    } catch (e) {}
}
</script>

<!-- FIREBASE & LEADERBOARD (FINAL WASD & ENTER FIX & MY RANK UI) -->
<script src="https://www.gstatic.com/firebasejs/12.6.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/12.6.0/firebase-firestore-compat.js"></script>
<script>
  (function () {
    const firebaseConfig = {
      apiKey: "AIzaSyBIOQqxS5fCFMLhkxXM4gQkfiANpLrNUV4",
      authDomain: "minsurvivor-3c2d1.firebaseapp.com",
      projectId: "minsurvivor-3c2d1",
      storageBucket: "minsurvivor-3c2d1.firebasestorage.app",
      messagingSenderId: "193473399866",
      appId: "1:193473399866:web:58359521495f4ebcddb903"
    };

    function $(id){ return document.getElementById(id); }
    function logDebug(action, value) { const time = new Date().toLocaleTimeString(); console.log(`%c[${time}] ${action}:`, "color: #00ff00; font-weight: bold;", value); }

    function getStatusEl(){ return $("lb-status") || $("lb-placeholder-text"); }
    function getListEl(){ return $("lb-top10"); }

    function setStatus(msg) {
      const el = getStatusEl(); if (!el) return;
      if (el.id === "lb-placeholder-text") el.innerHTML = String(msg || "").replace(/\\n/g, "<br>"); else el.textContent = msg || "";
    }

    function sanitizeName(name) { 
        return String(name || "").trim().replace(/\s+/g, " ").replace(/[^\w \-\u4e00-\u9fff]/g, "").slice(0, 12); 
    }

    function isNameLocked() { try { return localStorage.getItem("zr_name_locked") === "1"; } catch (e) { return false; } }
    
    function lockName(name) { 
        try { if (name) { localStorage.setItem("zr_player_name", name); localStorage.setItem("lb_name", name); localStorage.setItem("zr_name_locked", "1"); } } catch (e) {} 
    }

    function applyNameLockUI(inputEl) {
      if (!inputEl) return;
      const locked = isNameLocked();
      if (locked) { inputEl.readOnly = true; inputEl.disabled = true; inputEl.classList.add('nickname-locked'); } 
      else { inputEl.readOnly = false; inputEl.disabled = false; inputEl.classList.remove('nickname-locked'); }
    }

    function prefillName(inputEl) {
      try { const saved = localStorage.getItem("zr_player_name") || localStorage.getItem("lb_name") || ""; if (saved && inputEl) { inputEl.value = saved; } } catch (e) {}
      applyNameLockUI(inputEl);
    }

    function renderTop10(rows) {
      const listEl = getListEl(); if (!listEl) return; listEl.innerHTML = "";
      if (!rows || rows.length === 0) { const d = document.createElement("div"); d.style.color = "#888"; d.style.fontStyle = "italic"; d.textContent = "No scores yet."; listEl.appendChild(d); return; }
      rows.forEach((r, i) => {
        const item = document.createElement("div"); item.className = "lb-item";
        const left = document.createElement("div"); left.className = "lb-left";
        const rank = document.createElement("div"); rank.className = "lb-rank"; rank.textContent = "#"+(i+1);
        const name = document.createElement("div"); name.className = "lb-name"; name.textContent = r.nickname || "???";
        left.appendChild(rank); left.appendChild(name);
        const score = document.createElement("div"); score.className = "lb-score"; score.textContent = String(r.score ?? 0);
        item.appendChild(left); item.appendChild(score); listEl.appendChild(item);
      });
    }

    try { firebase.initializeApp(firebaseConfig); } catch (e) {}
    const db = firebase.firestore();

    // MODIFIED: Remove secondary sort to show all high scores
    async function loadTop10() {
      const snap = await db.collection("scores").orderBy("score", "desc").limit(10).get();
      return snap.docs.map(d => d.data());
    }

    // New Function to refresh BOTH Top 10 AND My Rank
    async function refreshTop10AndMyRank(myName) {
      try { 
          setStatus("Loading..."); 
          const rows = await loadTop10(); 
          renderTop10(rows); 
          setStatus(""); 
          
          if (myName) {
              await refreshMyRank(myName, rows);
          }
      } catch (e) { console.warn(e); setStatus("Leaderboard error: " + (e.message || e)); }
    }

    async function refreshMyRank(name, topRows) {
        const container = $("lb-my-rank-container");
        if (!container) return;
        // Keep clear at start for logic simplicity as requested in revert
        container.innerHTML = ''; 

        try {
            const ref = db.collection("scores").doc(name);
            const snap = await ref.get();
            if (!snap.exists) return; 

            const myData = snap.data();
            const myBest = myData.score || 0;
            
            // Check if I am in Top 10 list first (Visual Consistency)
            let rankDisplay = "?";
            let foundIndex = -1;
            
            if (topRows && topRows.length > 0) {
                foundIndex = topRows.findIndex(r => r.nickname === name);
            }

            if (foundIndex !== -1) {
                rankDisplay = "#" + (foundIndex + 1);
            } else {
                // Fallback query if not in top 10
                try {
                    const snapshot = await db.collection('scores').where('score', '>', myBest).get();
                    rankDisplay = "#" + (snapshot.size + 1);
                } catch(e) { console.log("Rank calc error", e); }
            }

            const item = document.createElement("div"); 
            item.className = "lb-item my-rank-row"; 
            
            const left = document.createElement("div"); 
            left.className = "lb-left";
            
            const rank = document.createElement("div"); 
            rank.className = "lb-rank"; 
            rank.textContent = rankDisplay;
            
            const nDiv = document.createElement("div"); 
            nDiv.className = "lb-name"; 
            nDiv.textContent = name;
            
            left.appendChild(rank); 
            left.appendChild(nDiv);
            
            const score = document.createElement("div"); 
            score.className = "lb-score"; 
            score.textContent = String(myBest);
            
            item.appendChild(left); 
            item.appendChild(score); 
            
            // Double clear just to be safe against race conditions (kept from your fix)
            container.innerHTML = '';
            container.appendChild(item);

        } catch(e) {}
    }

    async function submitScore(nickname, score) {
      const name = sanitizeName(nickname);
      const sc = Math.max(0, Math.floor(Number(score) || 0));
      if (!name) throw new Error("Please enter a nickname.");
      logDebug("API Submitting", { name: name, score: sc });
      const ref = db.collection("scores").doc(name);
      return await db.runTransaction(async (tx) => {
        const snap = await tx.get(ref);
        if (!snap.exists) { tx.set(ref, { nickname: name, score: sc, createdAt: firebase.firestore.FieldValue.serverTimestamp(), updatedAt: firebase.firestore.FieldValue.serverTimestamp() }); return { written: true, reason: "first", prevScore: 0 }; }
        const prev = snap.data() || {}; const prevScore = Number(prev.score || 0);
        if (sc > prevScore) { tx.set(ref, { nickname: name, score: sc, createdAt: prev.createdAt || firebase.firestore.FieldValue.serverTimestamp(), updatedAt: firebase.firestore.FieldValue.serverTimestamp() }, { merge: true }); return { written: true, reason: "improved", prevScore }; }
        return { written: false, reason: "not_higher", prevScore };
      });
    }

    let __autoSubmitPromise = null; let __submittedForThisOpen = false;
    function getFreshInputValue() { const el = $("player-name-input"); if (!el) return ""; return el.value; }

    function updateNameUI() {
      const inputEl = $("player-name-input"); 
      const currentVal = inputEl ? inputEl.value : "";
      let saved = ""; try { saved = (localStorage.getItem("zr_player_name") || localStorage.getItem("lb_name") || "").trim(); } catch(e) {}
      
      const effectiveName = currentVal.trim() || saved; 
      const cleanName = sanitizeName(effectiveName);

      if (cleanName && inputEl) {
          inputEl.value = cleanName;
          applyNameLockUI(inputEl);
      }
      return cleanName;
    }

    async function autoSubmitIfPossible() {
      if (__submittedForThisOpen) return; 
      
      const inputEl = $("player-name-input"); 
      try { if (inputEl) inputEl.blur(); } catch(e){} 
      
      if (inputEl) {
          inputEl.readOnly = true;
          inputEl.disabled = true;
          inputEl.classList.add('nickname-locked');
      }
      
      await new Promise(res => setTimeout(res, 50));

      const rawValue = getFreshInputValue();
      logDebug("Submit Triggered", `Raw DOM Value: "${rawValue}"`);
      const name = sanitizeName(rawValue); const sc = window.__GAME_SCORE__ ?? 0;
      
      if (!name) { 
          setStatus("Enter your name to save score."); 
          if (inputEl) { inputEl.readOnly = false; inputEl.disabled = false; inputEl.classList.remove('nickname-locked'); }
          return; 
      }
      
      try { 
          localStorage.setItem("zr_player_name", name); 
          localStorage.setItem("zr_name_locked", "1"); 
          logDebug("LocalStorage Updated", name); 
      } catch(e){}
      
      __submittedForThisOpen = true;
      setStatus("Submitting...");

      __autoSubmitPromise = (async () => {
        const result = await submitScore(name, sc); lockName(name); 
        setStatus(result && result.written ? "Saved!" : `Best kept: ${result?.prevScore ?? 0}`); 
        // Trigger BOTH updates here
        await refreshTop10AndMyRank(name);
        return result;
      })().catch((e) => { 
          console.warn(e); 
          setStatus(e.message || "Submit failed."); 
          __submittedForThisOpen = false; 
      });
      return __autoSubmitPromise;
    }

    function bindUI() {
      const nameInput = $("player-name-input"); if (!nameInput) return;
      
      // Stop ALL keys from reaching Phaser
      const stopProp = (e) => { e.stopPropagation(); };

      nameInput.addEventListener("keydown", async (e) => { 
          e.stopPropagation();
          if (e.key === "Enter" || e.keyCode === 13) {
              if (e.isComposing) return; 
              e.preventDefault(); 
              logDebug("Key pressed", "ENTER (Immediate Submit)");
              await autoSubmitIfPossible();
          }
      });

      ['keypress', 'keyup'].forEach(evt => nameInput.addEventListener(evt, stopProp));
      ['pointerdown','pointerup','mousedown','mouseup','touchstart','touchend'].forEach(evt => nameInput.addEventListener(evt, stopProp));

      nameInput.addEventListener("input", (e) => { logDebug("Typing", e.target.value); });
      nameInput.addEventListener("blur", (e) => { 
          logDebug("Blur", e.target.value); 
          if (e.target.value.trim().length > 0 && !__submittedForThisOpen) { autoSubmitIfPossible(); } 
      });
      updateNameUI();
    }

    window.LeaderboardAPI = {
      open: async function ({ score, nameInputId }) {
        const inputEl = document.getElementById(nameInputId); prefillName(inputEl); window.__GAME_SCORE__ = score;
        __submittedForThisOpen = false; 
        bindUI(); 
        const name = updateNameUI(); 
        
        // Initial load (pass name to try loading my rank if exists)
        await refreshTop10AndMyRank(name);

        if (!isNameLocked()) {
             setStatus("Enter your name to save score."); try { if (inputEl) inputEl.focus(); } catch(e){} 
        } else {
             autoSubmitIfPossible();
        }
      },
      beforePlayAgain: async function () { return await (__autoSubmitPromise || autoSubmitIfPossible() || Promise.resolve()); },
      refreshTop10: () => refreshTop10AndMyRank(getFreshInputValue())
    };
    if (document.readyState === "loading") { document.addEventListener("DOMContentLoaded", bindUI); } else { bindUI(); }
    
    // Initial check (don't know name yet)
    refreshTop10AndMyRank(null);
    setStatus("Checking server...");
  })();
</script>

</body>
</html>